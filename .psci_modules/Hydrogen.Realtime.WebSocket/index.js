// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//                                                      // hydrogen // websocket
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// | WebSocket client with automatic reconnection
// |
// | Type-safe WebSocket management with JSON serialization,
// | heartbeats, and automatic reconnection with exponential backoff.
// |
// | ## Usage
// |
// | ```purescript
// | import Hydrogen.Realtime.WebSocket as WS
// |
// | -- Create connection
// | ws <- WS.connect "wss://api.example.com/ws"
// |   { onOpen: Console.log "Connected!"
// |   , onClose: Console.log "Disconnected"
// |   , onError: \err -> Console.log $ "Error: " <> err
// |   , onMessage: \msg -> handleMessage msg
// |   , reconnect: true
// |   }
// |
// | -- Send messages
// | WS.send ws { type: "subscribe", channel: "updates" }
// |
// | -- Close connection
// | WS.close ws
// | ```
import * as $foreign from "./foreign.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Argonaut_Core from "../Data.Argonaut.Core/index.js";
import * as Data_Argonaut_Encode_Class from "../Data.Argonaut.Encode.Class/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Function from "../Data.Function/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect from "../Effect/index.js";
import * as Effect_Aff from "../Effect.Aff/index.js";
import * as Effect_Class from "../Effect.Class/index.js";
import * as Effect_Ref from "../Effect.Ref/index.js";
var pure = /* #__PURE__ */ Control_Applicative.pure(Effect.applicativeEffect);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit);
var $$void = /* #__PURE__ */ Data_Functor["void"](Effect.functorEffect);
var foldM = /* #__PURE__ */ Data_Array.foldM(Effect.monadEffect);
var when = /* #__PURE__ */ Control_Applicative.when(Effect.applicativeEffect);
var discard2 = /* #__PURE__ */ discard(Effect_Aff.bindAff);
var liftEffect = /* #__PURE__ */ Effect_Class.liftEffect(Effect_Aff.monadEffectAff);

// | WebSocket connection state
var Connecting = /* #__PURE__ */ (function () {
    function Connecting() {

    };
    Connecting.value = new Connecting();
    return Connecting;
})();

// | WebSocket connection state
var Open = /* #__PURE__ */ (function () {
    function Open() {

    };
    Open.value = new Open();
    return Open;
})();

// | WebSocket connection state
var Closing = /* #__PURE__ */ (function () {
    function Closing() {

    };
    Closing.value = new Closing();
    return Closing;
})();

// | WebSocket connection state
var Closed = /* #__PURE__ */ (function () {
    function Closed() {

    };
    Closed.value = new Closed();
    return Closed;
})();

// | Subscription channel
var Channel = function (x) {
    return x;
};

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                       // types
// ═══════════════════════════════════════════════════════════════════════════════
// | WebSocket connection wrapper
var WebSocketConnection = function (x) {
    return x;
};

// | Unsubscribe from a channel entirely
var unsubscribeChannel = function (v) {
    return function (v1) {
        return Effect_Ref.modify_(Data_Array.filter(function (v2) {
            return v2.name !== v1.name;
        }))(v.channels);
    };
};

// | Subscribe to a channel
var subscribeChannel = function (v) {
    return function (v1) {
        return function (handler) {
            var unless = function (cond) {
                return function (act) {
                    if (cond) {
                        return pure(Data_Unit.unit);
                    };
                    return act;
                };
            };
            return function __do() {
                var chans = Effect_Ref.read(v.channels)();
                var hasChannel = Data_Array.any(function (v2) {
                    return v2.name === v1.name;
                })(chans);
                unless(hasChannel)(Effect_Ref.modify_(Data_Function.flip(Data_Array.snoc)(v1))(v.channels))();
                var handlerId = Effect_Ref.read(v1.nextHandlerId)();
                Effect_Ref.write(handlerId + 1 | 0)(v1.nextHandlerId)();
                var h = {
                    id: handlerId,
                    callback: handler
                };
                Effect_Ref.modify_(Data_Function.flip(Data_Array.snoc)(h))(v1.handlers)();
                return Effect_Ref.modify_(Data_Array.filter(function (x) {
                    return x.id !== handlerId;
                }))(v1.handlers);
            };
        };
    };
};
var showWebSocketState = {
    show: function (v) {
        if (v instanceof Connecting) {
            return "Connecting";
        };
        if (v instanceof Open) {
            return "Open";
        };
        if (v instanceof Closing) {
            return "Closing";
        };
        if (v instanceof Closed) {
            return "Closed";
        };
        throw new Error("Failed pattern match at Hydrogen.Realtime.WebSocket (line 104, column 1 - line 108, column 25): " + [ v.constructor.name ]);
    }
};

// | Send raw text
var sendText = function (v) {
    return function (text) {
        return function __do() {
            var maybeWs = Effect_Ref.read(v.socket)();
            if (maybeWs instanceof Data_Maybe.Nothing) {
                return Data_Unit.unit;
            };
            if (maybeWs instanceof Data_Maybe.Just) {
                return $foreign.wsSend(maybeWs.value0)(text)();
            };
            throw new Error("Failed pattern match at Hydrogen.Realtime.WebSocket (line 270, column 3 - line 272, column 30): " + [ maybeWs.constructor.name ]);
        };
    };
};

// | Send raw JSON
var sendJson = function (conn) {
    return function (json) {
        return sendText(conn)(Data_Argonaut_Core.stringify(json));
    };
};

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                   // messaging
// ═══════════════════════════════════════════════════════════════════════════════
// | Send a JSON-encodable message
var send = function (dictEncodeJson) {
    var encodeJson = Data_Argonaut_Encode_Class.encodeJson(dictEncodeJson);
    return function (conn) {
        return function (msg) {
            return sendJson(conn)(encodeJson(msg));
        };
    };
};

// | Get the WebSocket URL
var getUrl = function (v) {
    return v.url;
};

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                       // state
// ═══════════════════════════════════════════════════════════════════════════════
// | Get current connection state
var getState = function (v) {
    return Effect_Ref.read(v.state);
};
var eqWebSocketState = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Connecting && y instanceof Connecting) {
                return true;
            };
            if (x instanceof Open && y instanceof Open) {
                return true;
            };
            if (x instanceof Closing && y instanceof Closing) {
                return true;
            };
            if (x instanceof Closed && y instanceof Closed) {
                return true;
            };
            return false;
        };
    }
};
var eq2 = /* #__PURE__ */ Data_Eq.eq(eqWebSocketState);

// | Check if connected
var isConnected = function (conn) {
    return function __do() {
        var s = getState(conn)();
        return eq2(s)(Open.value);
    };
};

// | Internal connection logic
var doConnect = function (v) {
    var unwrapConn = function (v1) {
        return v1;
    };
    var toNumber = function (n) {
        var $69 = n === 0;
        if ($69) {
            return 0.0;
        };
        return toNumber(n - 1 | 0) + 1.0;
    };
    var pow = function (base) {
        return function (exp) {
            var $70 = exp <= 0.0;
            if ($70) {
                return 1.0;
            };
            return base * pow(base)(exp - 1.0);
        };
    };
    var forHandlers = function (arr) {
        return function (f) {
            return $$void(foldM(function (v1) {
                return function (x) {
                    return f(x);
                };
            })(Data_Unit.unit)(arr));
        };
    };
    var forChannels = function (arr) {
        return function (f) {
            return $$void(foldM(function (v1) {
                return function (x) {
                    return f(x);
                };
            })(Data_Unit.unit)(arr));
        };
    };
    return function __do() {
        Effect_Ref.write(Connecting.value)(v.state)();
        var ws = $foreign.newWebSocket(v.url)(v.config.protocols)();
        Effect_Ref.write(new Data_Maybe.Just(ws))(v.socket)();
        $foreign.wsOnOpen(ws)(function __do() {
            Effect_Ref.write(Open.value)(v.state)();
            Effect_Ref.write(0)(v.retryCount)();
            return v.config.onOpen();
        })();
        $foreign.wsOnClose(ws)(function __do() {
            Effect_Ref.write(Closed.value)(v.state)();
            v.config.onClose();
            return when(v.config.reconnect)(function __do() {
                var retries = Effect_Ref.read(v.retryCount)();
                return when(retries < v.config.maxRetries)(function __do() {
                    Effect_Ref.modify_(function (v1) {
                        return v1 + 1 | 0;
                    })(v.retryCount)();
                    var delayMs = 1000.0 * pow(2.0)(toNumber(retries));
                    return Effect_Aff.launchAff_(discard2(Effect_Aff.delay(delayMs))(function () {
                        return liftEffect(doConnect(v));
                    }))();
                })();
            })();
        })();
        $foreign.wsOnError(ws)(function (err) {
            return v.config.onError(err);
        })();
        return $foreign.wsOnMessage(ws)(function (msg) {
            return function __do() {
                v.config.onMessage(msg)();
                var channels = Effect_Ref.read((unwrapConn(v)).channels)();
                return forChannels(channels)(function (v1) {
                    return function __do() {
                        var handlers = Effect_Ref.read(v1.handlers)();
                        return forHandlers(handlers)(function (h) {
                            return h.callback(msg);
                        })();
                    };
                })();
            };
        })();
    };
};

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                  // connection
// ═══════════════════════════════════════════════════════════════════════════════
// | Default WebSocket configuration
var defaultConfig = /* #__PURE__ */ (function () {
    return {
        onOpen: pure(Data_Unit.unit),
        onClose: pure(Data_Unit.unit),
        onError: function (v) {
            return pure(Data_Unit.unit);
        },
        onMessage: function (v) {
            return pure(Data_Unit.unit);
        },
        reconnect: true,
        maxRetries: 5,
        heartbeatInterval: new Data_Maybe.Just(30000.0),
        protocols: [  ]
    };
})();

// | Create a named channel for message routing
var createChannel = function (name) {
    return function __do() {
        var handlers = Effect_Ref["new"]([  ])();
        var nextHandlerId = Effect_Ref["new"](0)();
        return {
            name: name,
            handlers: handlers,
            nextHandlerId: nextHandlerId
        };
    };
};

// | Connect with specific subprotocols
var connectWithProtocol = function (url) {
    return function (protocols) {
        return function (config) {
            return function __do() {
                var socketRef = Effect_Ref["new"](Data_Maybe.Nothing.value)();
                var stateRef = Effect_Ref["new"](Connecting.value)();
                var retryRef = Effect_Ref["new"](0)();
                var channelsRef = Effect_Ref["new"]([  ])();
                var conn = {
                    socket: socketRef,
                    url: url,
                    config: config,
                    state: stateRef,
                    retryCount: retryRef,
                    channels: channelsRef
                };
                doConnect(conn)();
                return conn;
            };
        };
    };
};

// | Connect to a WebSocket server
var connect = function (url) {
    return function (config) {
        return connectWithProtocol(url)(config.protocols)(config);
    };
};

// | Close with a specific code and reason
var closeWithCode = function (v) {
    return function (code) {
        return function (reason) {
            return function __do() {
                Effect_Ref.write(Closing.value)(v.state)();
                var maybeWs = Effect_Ref.read(v.socket)();
                if (maybeWs instanceof Data_Maybe.Nothing) {
                    return Data_Unit.unit;
                };
                if (maybeWs instanceof Data_Maybe.Just) {
                    return $foreign.wsCloseWithCode(maybeWs.value0)(code)(reason)();
                };
                throw new Error("Failed pattern match at Hydrogen.Realtime.WebSocket (line 250, column 3 - line 252, column 46): " + [ maybeWs.constructor.name ]);
            };
        };
    };
};

// | Close the WebSocket connection
var close = function (v) {
    return function __do() {
        Effect_Ref.write(Closing.value)(v.state)();
        var maybeWs = Effect_Ref.read(v.socket)();
        if (maybeWs instanceof Data_Maybe.Nothing) {
            return Data_Unit.unit;
        };
        if (maybeWs instanceof Data_Maybe.Just) {
            return $foreign.wsClose(maybeWs.value0)();
        };
        throw new Error("Failed pattern match at Hydrogen.Realtime.WebSocket (line 241, column 3 - line 243, column 26): " + [ maybeWs.constructor.name ]);
    };
};
export {
    Connecting,
    Open,
    Closing,
    Closed,
    connect,
    connectWithProtocol,
    close,
    closeWithCode,
    send,
    sendJson,
    sendText,
    getState,
    isConnected,
    getUrl,
    createChannel,
    subscribeChannel,
    unsubscribeChannel,
    eqWebSocketState,
    showWebSocketState
};
