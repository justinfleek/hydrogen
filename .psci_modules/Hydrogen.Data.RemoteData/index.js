// | A data type for values fetched from a remote source.
// |
// | RemoteData represents the complete lifecycle of an async request:
// |
// | ```
// | NotAsked --> Loading --> Success a
// |                    \--> Failure e
// | ```
// |
// | This eliminates impossible states. You cannot have both an error and data.
// | You cannot forget to handle the loading state. The compiler enforces it.
// |
// | ## Laws
// |
// | RemoteData forms a lawful Monad where:
// | - `pure = Success`
// | - `>>=` short-circuits on NotAsked, Loading, Failure (left-to-right)
// |
// | The Applicative instance is "first failure" semantics:
// | - If any argument is `Failure`, the result is `Failure`
// | - If any argument is `Loading`, the result is `Loading`  
// | - If any argument is `NotAsked`, the result is `NotAsked`
// |
// | Priority order: Failure > Loading > NotAsked > Success
// |
// | ## Semigroup
// |
// | `<>` takes the "most progressed" value:
// | - `Success a <> Success b = Success b` (right-biased)
// | - `Success a <> Loading = Success a` (success wins)
// | - `Failure e <> Success a = Success a` (success wins over failure)
// | - `Loading <> Failure e = Failure e` (failure wins over loading)
// |
// | This means you can use `<>` to "upgrade" state as responses arrive.
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Apply from "../Control.Apply/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Monoid from "../Data.Monoid/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Ordering from "../Data.Ordering/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Traversable from "../Data.Traversable/index.js";

// | Represents data that is fetched from a remote source.
// |
// | - `NotAsked` - Request has not been made yet
// | - `Loading` - Request is in flight
// | - `Failure e` - Request failed with error `e`
// | - `Success a` - Request succeeded with value `a`
var NotAsked = /* #__PURE__ */ (function () {
    function NotAsked() {

    };
    NotAsked.value = new NotAsked();
    return NotAsked;
})();

// | Represents data that is fetched from a remote source.
// |
// | - `NotAsked` - Request has not been made yet
// | - `Loading` - Request is in flight
// | - `Failure e` - Request failed with error `e`
// | - `Success a` - Request succeeded with value `a`
var Loading = /* #__PURE__ */ (function () {
    function Loading() {

    };
    Loading.value = new Loading();
    return Loading;
})();

// | Represents data that is fetched from a remote source.
// |
// | - `NotAsked` - Request has not been made yet
// | - `Loading` - Request is in flight
// | - `Failure e` - Request failed with error `e`
// | - `Success a` - Request succeeded with value `a`
var Failure = /* #__PURE__ */ (function () {
    function Failure(value0) {
        this.value0 = value0;
    };
    Failure.create = function (value0) {
        return new Failure(value0);
    };
    return Failure;
})();

// | Represents data that is fetched from a remote source.
// |
// | - `NotAsked` - Request has not been made yet
// | - `Loading` - Request is in flight
// | - `Failure e` - Request failed with error `e`
// | - `Success a` - Request succeeded with value `a`
var Success = /* #__PURE__ */ (function () {
    function Success(value0) {
        this.value0 = value0;
    };
    Success.create = function (value0) {
        return new Success(value0);
    };
    return Success;
})();

// | Get Success value or fall back to default.
var withDefault = function (def) {
    return function (v) {
        if (v instanceof Success) {
            return v.value0;
        };
        return def;
    };
};

// | Extract Success value as Maybe. Everything else is Nothing.
var toMaybe = function (v) {
    if (v instanceof Success) {
        return new Data_Maybe.Just(v.value0);
    };
    return Data_Maybe.Nothing.value;
};

// =============================================================================
//                                                                // elimination
// =============================================================================
// | Convert to Either. NotAsked and Loading become Left with provided error.
var toEither = function (pending) {
    return function (v) {
        if (v instanceof NotAsked) {
            return new Data_Either.Left(pending);
        };
        if (v instanceof Loading) {
            return new Data_Either.Left(pending);
        };
        if (v instanceof Failure) {
            return new Data_Either.Left(v.value0);
        };
        if (v instanceof Success) {
            return new Data_Either.Right(v.value0);
        };
        throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 206, column 20 - line 210, column 23): " + [ v.constructor.name ]);
    };
};
var showRemoteData = function (dictShow) {
    var show = Data_Show.show(dictShow);
    return function (dictShow1) {
        var show1 = Data_Show.show(dictShow1);
        return {
            show: function (v) {
                if (v instanceof NotAsked) {
                    return "NotAsked";
                };
                if (v instanceof Loading) {
                    return "Loading";
                };
                if (v instanceof Failure) {
                    return "(Failure " + (show(v.value0) + ")");
                };
                if (v instanceof Success) {
                    return "(Success " + (show1(v.value0) + ")");
                };
                throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 88, column 1 - line 92, column 50): " + [ v.constructor.name ]);
            }
        };
    };
};

// | Semigroup: combine by taking most-progressed state
// | Success > Failure > Loading > NotAsked (for structure)
// | When both are Success, right-biased (takes second value)
var semigroupRemoteData = function (dictSemigroup) {
    var append1 = Data_Semigroup.append(dictSemigroup);
    return {
        append: function (v) {
            return function (v1) {
                if (v instanceof Success && v1 instanceof Success) {
                    return new Success(append1(v.value0)(v1.value0));
                };
                if (v instanceof Success) {
                    return new Success(v.value0);
                };
                if (v1 instanceof Success) {
                    return new Success(v1.value0);
                };
                if (v instanceof Failure) {
                    return new Failure(v.value0);
                };
                if (v1 instanceof Failure) {
                    return new Failure(v1.value0);
                };
                if (v instanceof Loading) {
                    return Loading.value;
                };
                if (v1 instanceof Loading) {
                    return Loading.value;
                };
                if (v instanceof NotAsked && v1 instanceof NotAsked) {
                    return NotAsked.value;
                };
                throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 148, column 1 - line 156, column 38): " + [ v.constructor.name, v1.constructor.name ]);
            };
        }
    };
};

// | Monoid: NotAsked is identity
var monoidRemoteData = function (dictSemigroup) {
    var semigroupRemoteData1 = semigroupRemoteData(dictSemigroup);
    return {
        mempty: NotAsked.value,
        Semigroup0: function () {
            return semigroupRemoteData1;
        }
    };
};

// =============================================================================
//                                                            // transformations
// =============================================================================
// | Map over the error type only.
var mapError = function (v) {
    return function (v1) {
        if (v1 instanceof NotAsked) {
            return NotAsked.value;
        };
        if (v1 instanceof Loading) {
            return Loading.value;
        };
        if (v1 instanceof Failure) {
            return new Failure(v(v1.value0));
        };
        if (v1 instanceof Success) {
            return new Success(v1.value0);
        };
        throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 274, column 1 - line 274, column 77): " + [ v.constructor.name, v1.constructor.name ]);
    };
};
var isSuccess = function (v) {
    if (v instanceof Success) {
        return true;
    };
    return false;
};

// =============================================================================
//                                                                 // predicates
// =============================================================================
var isNotAsked = function (v) {
    if (v instanceof NotAsked) {
        return true;
    };
    return false;
};
var isLoading = function (v) {
    if (v instanceof Loading) {
        return true;
    };
    return false;
};
var isFailure = function (v) {
    if (v instanceof Failure) {
        return true;
    };
    return false;
};
var functorRemoteData = {
    map: function (f) {
        return function (m) {
            if (m instanceof NotAsked) {
                return NotAsked.value;
            };
            if (m instanceof Loading) {
                return Loading.value;
            };
            if (m instanceof Failure) {
                return new Failure(m.value0);
            };
            if (m instanceof Success) {
                return new Success(f(m.value0));
            };
            throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 0, column 0 - line 0, column 0): " + [ m.constructor.name ]);
        };
    }
};
var map = /* #__PURE__ */ Data_Functor.map(functorRemoteData);

// | Convert from Maybe. Nothing becomes the provided error, Just becomes Success.
var fromMaybe = function (e) {
    return Data_Maybe.maybe(new Failure(e))(Success.create);
};

// =============================================================================
//                                                               // construction
// =============================================================================
// | Convert from Either. Left becomes Failure, Right becomes Success.
var fromEither = function (v) {
    if (v instanceof Data_Either.Left) {
        return new Failure(v.value0);
    };
    if (v instanceof Data_Either.Right) {
        return new Success(v.value0);
    };
    throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 192, column 1 - line 192, column 55): " + [ v.constructor.name ]);
};

// | Foldable: only Success contains a value to fold
var foldableRemoteData = {
    foldr: function (f) {
        return function (b) {
            return function (v) {
                if (v instanceof Success) {
                    return f(v.value0)(b);
                };
                return b;
            };
        };
    },
    foldl: function (f) {
        return function (b) {
            return function (v) {
                if (v instanceof Success) {
                    return f(b)(v.value0);
                };
                return b;
            };
        };
    },
    foldMap: function (dictMonoid) {
        var mempty = Data_Monoid.mempty(dictMonoid);
        return function (f) {
            return function (v) {
                if (v instanceof Success) {
                    return f(v.value0);
                };
                return mempty;
            };
        };
    }
};

// | Traversable: traverse the success case
var traversableRemoteData = {
    traverse: function (dictApplicative) {
        var pure = Control_Applicative.pure(dictApplicative);
        var map1 = Data_Functor.map((dictApplicative.Apply0()).Functor0());
        return function (f) {
            return function (v) {
                if (v instanceof NotAsked) {
                    return pure(NotAsked.value);
                };
                if (v instanceof Loading) {
                    return pure(Loading.value);
                };
                if (v instanceof Failure) {
                    return pure(new Failure(v.value0));
                };
                if (v instanceof Success) {
                    return map1(Success.create)(f(v.value0));
                };
                throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 176, column 16 - line 180, column 33): " + [ v.constructor.name ]);
            };
        };
    },
    sequence: function (dictApplicative) {
        var pure = Control_Applicative.pure(dictApplicative);
        var map1 = Data_Functor.map((dictApplicative.Apply0()).Functor0());
        return function (v) {
            if (v instanceof NotAsked) {
                return pure(NotAsked.value);
            };
            if (v instanceof Loading) {
                return pure(Loading.value);
            };
            if (v instanceof Failure) {
                return pure(new Failure(v.value0));
            };
            if (v instanceof Success) {
                return map1(Success.create)(v.value0);
            };
            throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 181, column 14 - line 185, column 33): " + [ v.constructor.name ]);
        };
    },
    Functor0: function () {
        return functorRemoteData;
    },
    Foldable1: function () {
        return foldableRemoteData;
    }
};

// | Eliminate RemoteData by providing handlers for each case.
// |
// | ```purescript
// | fold 
// |   { notAsked: HH.text "Click to load"
// |   , loading: spinner
// |   , failure: \e -> errorMessage e
// |   , success: \data -> renderData data
// |   }
// |   remoteData
// | ```
var fold = function (handlers) {
    return function (v) {
        if (v instanceof NotAsked) {
            return handlers.notAsked;
        };
        if (v instanceof Loading) {
            return handlers.loading;
        };
        if (v instanceof Failure) {
            return handlers.failure(v.value0);
        };
        if (v instanceof Success) {
            return handlers.success(v.value0);
        };
        throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 237, column 17 - line 241, column 34): " + [ v.constructor.name ]);
    };
};
var eqRemoteData = function (dictEq) {
    var eq = Data_Eq.eq(dictEq);
    return function (dictEq1) {
        var eq1 = Data_Eq.eq(dictEq1);
        return {
            eq: function (x) {
                return function (y) {
                    if (x instanceof NotAsked && y instanceof NotAsked) {
                        return true;
                    };
                    if (x instanceof Loading && y instanceof Loading) {
                        return true;
                    };
                    if (x instanceof Failure && y instanceof Failure) {
                        return eq(x.value0)(y.value0);
                    };
                    if (x instanceof Success && y instanceof Success) {
                        return eq1(x.value0)(y.value0);
                    };
                    return false;
                };
            }
        };
    };
};
var ordRemoteData = function (dictOrd) {
    var compare = Data_Ord.compare(dictOrd);
    var eqRemoteData1 = eqRemoteData(dictOrd.Eq0());
    return function (dictOrd1) {
        var compare1 = Data_Ord.compare(dictOrd1);
        var eqRemoteData2 = eqRemoteData1(dictOrd1.Eq0());
        return {
            compare: function (x) {
                return function (y) {
                    if (x instanceof NotAsked && y instanceof NotAsked) {
                        return Data_Ordering.EQ.value;
                    };
                    if (x instanceof NotAsked) {
                        return Data_Ordering.LT.value;
                    };
                    if (y instanceof NotAsked) {
                        return Data_Ordering.GT.value;
                    };
                    if (x instanceof Loading && y instanceof Loading) {
                        return Data_Ordering.EQ.value;
                    };
                    if (x instanceof Loading) {
                        return Data_Ordering.LT.value;
                    };
                    if (y instanceof Loading) {
                        return Data_Ordering.GT.value;
                    };
                    if (x instanceof Failure && y instanceof Failure) {
                        return compare(x.value0)(y.value0);
                    };
                    if (x instanceof Failure) {
                        return Data_Ordering.LT.value;
                    };
                    if (y instanceof Failure) {
                        return Data_Ordering.GT.value;
                    };
                    if (x instanceof Success && y instanceof Success) {
                        return compare1(x.value0)(y.value0);
                    };
                    throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 0, column 0 - line 0, column 0): " + [ x.constructor.name, y.constructor.name ]);
                };
            },
            Eq0: function () {
                return eqRemoteData2;
            }
        };
    };
};

// | Bifunctor: map over both error and success types
var bifunctorRemoteData = {
    bimap: function (v) {
        return function (v1) {
            return function (v2) {
                if (v2 instanceof NotAsked) {
                    return NotAsked.value;
                };
                if (v2 instanceof Loading) {
                    return Loading.value;
                };
                if (v2 instanceof Failure) {
                    return new Failure(v(v2.value0));
                };
                if (v2 instanceof Success) {
                    return new Success(v1(v2.value0));
                };
                throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 117, column 1 - line 121, column 40): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
            };
        };
    }
};

// | First-failure Applicative semantics.
// | Priority: Failure > Loading > NotAsked > Success
var applyRemoteData = {
    apply: function (v) {
        return function (v1) {
            if (v instanceof Success && v1 instanceof Success) {
                return new Success(v.value0(v1.value0));
            };
            if (v instanceof Failure) {
                return new Failure(v.value0);
            };
            if (v1 instanceof Failure) {
                return new Failure(v1.value0);
            };
            if (v instanceof Loading) {
                return Loading.value;
            };
            if (v1 instanceof Loading) {
                return Loading.value;
            };
            if (v instanceof NotAsked) {
                return NotAsked.value;
            };
            if (v1 instanceof NotAsked) {
                return NotAsked.value;
            };
            throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 96, column 1 - line 103, column 30): " + [ v.constructor.name, v1.constructor.name ]);
        };
    },
    Functor0: function () {
        return functorRemoteData;
    }
};
var apply = /* #__PURE__ */ Control_Apply.apply(applyRemoteData);
var bindRemoteData = {
    bind: function (v) {
        return function (v1) {
            if (v instanceof NotAsked) {
                return NotAsked.value;
            };
            if (v instanceof Loading) {
                return Loading.value;
            };
            if (v instanceof Failure) {
                return new Failure(v.value0);
            };
            if (v instanceof Success) {
                return v1(v.value0);
            };
            throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 108, column 1 - line 112, column 27): " + [ v.constructor.name, v1.constructor.name ]);
        };
    },
    Apply0: function () {
        return applyRemoteData;
    }
};

// =============================================================================
//                                                                  // combining
// =============================================================================
// | Combine two RemoteData values. Both must succeed.
var map2 = function (f) {
    return function (ra) {
        return function (rb) {
            return apply(map(f)(ra))(rb);
        };
    };
};

// | Combine three RemoteData values. All must succeed.
var map3 = function (f) {
    return function (ra) {
        return function (rb) {
            return function (rc) {
                return apply(apply(map(f)(ra))(rb))(rc);
            };
        };
    };
};

// | Combine four RemoteData values. All must succeed.
var map4 = function (f) {
    return function (ra) {
        return function (rb) {
            return function (rc) {
                return function (rd) {
                    return apply(apply(apply(map(f)(ra))(rb))(rc))(rd);
                };
            };
        };
    };
};
var applicativeRemoteData = /* #__PURE__ */ (function () {
    return {
        pure: Success.create,
        Apply0: function () {
            return applyRemoteData;
        }
    };
})();
var monadRemoteData = {
    Applicative0: function () {
        return applicativeRemoteData;
    },
    Bind1: function () {
        return bindRemoteData;
    }
};

// | Sequence an array of RemoteData into RemoteData of array.
// | All must succeed for the result to be Success.
var sequence = /* #__PURE__ */ Data_Traversable.sequence(Data_Traversable.traversableArray)(applicativeRemoteData);

// | Traverse with a function that returns RemoteData.
var traverse = /* #__PURE__ */ Data_Traversable.traverse(Data_Traversable.traversableArray)(applicativeRemoteData);

// | Alt: first success wins, NotAsked is identity
// | 
// | Laws:
// | - `NotAsked <|> x = x` (left identity for Plus)
// | - `Success a <|> _ = Success a` (success is absorbing on left)
// | - `_ <|> Success a = Success a` (success wins)
// |
// | For non-Success: prefer the "more progressed" state
// | Priority: Failure > Loading > NotAsked
var altRemoteData = {
    alt: function (v) {
        return function (v1) {
            if (v instanceof NotAsked) {
                return v1;
            };
            if (v1 instanceof NotAsked) {
                return v;
            };
            if (v instanceof Success) {
                return new Success(v.value0);
            };
            if (v1 instanceof Success) {
                return new Success(v1.value0);
            };
            if (v instanceof Failure) {
                return new Failure(v.value0);
            };
            if (v1 instanceof Failure) {
                return new Failure(v1.value0);
            };
            if (v instanceof Loading && v1 instanceof Loading) {
                return Loading.value;
            };
            throw new Error("Failed pattern match at Hydrogen.Data.RemoteData (line 132, column 1 - line 139, column 32): " + [ v.constructor.name, v1.constructor.name ]);
        };
    },
    Functor0: function () {
        return functorRemoteData;
    }
};

// | Plus: NotAsked is the identity for Alt
var plusRemoteData = /* #__PURE__ */ (function () {
    return {
        empty: NotAsked.value,
        Alt0: function () {
            return altRemoteData;
        }
    };
})();
export {
    NotAsked,
    Loading,
    Failure,
    Success,
    fromEither,
    fromMaybe,
    toEither,
    toMaybe,
    fold,
    withDefault,
    isNotAsked,
    isLoading,
    isFailure,
    isSuccess,
    mapError,
    map2,
    map3,
    map4,
    sequence,
    traverse,
    eqRemoteData,
    ordRemoteData,
    functorRemoteData,
    showRemoteData,
    applyRemoteData,
    applicativeRemoteData,
    bindRemoteData,
    monadRemoteData,
    bifunctorRemoteData,
    altRemoteData,
    plusRemoteData,
    semigroupRemoteData,
    monoidRemoteData,
    foldableRemoteData,
    traversableRemoteData
};
