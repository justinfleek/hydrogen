// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//                                                      // hydrogen // linechart
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// | Line/Area chart component
// |
// | SVG-based line and area charts with smooth curves, tooltips, and animations.
// |
// | ## Usage
// |
// | ```purescript
// | import Hydrogen.Chart.LineChart as LineChart
// |
// | -- Simple line chart
// | LineChart.lineChart
// |   { data: [ { x: 0.0, y: 10.0 }
// |           , { x: 1.0, y: 25.0 }
// |           , { x: 2.0, y: 15.0 }
// |           ]
// |   , width: 400
// |   , height: 300
// |   }
// |
// | -- Area chart with gradient fill
// | LineChart.areaChart
// |   { data: values
// |   , width: 400
// |   , height: 300
// |   , color: "#3b82f6"
// |   }
// |
// | -- Multi-series line chart
// | LineChart.multiLineChart
// |   { series: [ { label: "Sales", data: salesData, color: "#3b82f6" }
// |             , { label: "Revenue", data: revenueData, color: "#10b981" }
// |             ]
// |   , width: 400
// |   , height: 300
// |   }
// |
// | -- With Bezier curves
// | LineChart.lineChartWithProps
// |   defaultProps
// |     { data = myData
// |     , curveType = Bezier
// |     , showDots = true
// |     }
// | ```
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Halogen_HTML_Core from "../Halogen.HTML.Core/index.js";
import * as Halogen_HTML_Elements from "../Halogen.HTML.Elements/index.js";
import * as Halogen_HTML_Properties from "../Halogen.HTML.Properties/index.js";
import * as Hydrogen_UI_Core from "../Hydrogen.UI.Core/index.js";
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var minimum = /* #__PURE__ */ Data_Foldable.minimum(Data_Ord.ordNumber)(Data_Foldable.foldableArray);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var maximum = /* #__PURE__ */ Data_Foldable.maximum(Data_Ord.ordNumber)(Data_Foldable.foldableArray);
var append1 = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var show1 = /* #__PURE__ */ Data_Show.show(Data_Show.showInt);
var bind = /* #__PURE__ */ Control_Bind.bind(Control_Bind.bindArray);

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                 // curve types
// ═══════════════════════════════════════════════════════════════════════════════
// | Line interpolation type
var Linear = /* #__PURE__ */ (function () {
    function Linear() {

    };
    Linear.value = new Linear();
    return Linear;
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                 // curve types
// ═══════════════════════════════════════════════════════════════════════════════
// | Line interpolation type
var Bezier = /* #__PURE__ */ (function () {
    function Bezier() {

    };
    Bezier.value = new Bezier();
    return Bezier;
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                 // curve types
// ═══════════════════════════════════════════════════════════════════════════════
// | Line interpolation type
var Step = /* #__PURE__ */ (function () {
    function Step() {

    };
    Step.value = new Step();
    return Step;
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                 // curve types
// ═══════════════════════════════════════════════════════════════════════════════
// | Line interpolation type
var StepBefore = /* #__PURE__ */ (function () {
    function StepBefore() {

    };
    StepBefore.value = new StepBefore();
    return StepBefore;
})();

// | Set line stroke width
var strokeWidth = function (w) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            strokeWidth: w
        };
    };
};

// | Set line stroke color
var strokeColor = function (c) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            strokeColor: c
        };
    };
};

// | Show/hide tooltips
var showTooltip = function (v) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            showTooltip: v
        };
    };
};

// | Show/hide legend
var showLegend = function (v) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            showLegend: v
        };
    };
};

// | Show/hide grid lines
var showGrid = function (v) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            showGrid: v
        };
    };
};

// | Show/hide data point dots
var showDots = function (v) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            showDots: v
        };
    };
};

// | Show/hide crosshair cursor
var showCrosshair = function (v) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            showCrosshair: v
        };
    };
};

// | Show/hide axis labels
var showAxisLabels = function (v) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            showAxisLabels: v
        };
    };
};

// | Step function (horizontal then vertical)
var generateStepPath = function (points) {
    var v = Data_Array.uncons(points);
    if (v instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v instanceof Data_Maybe.Just) {
        return "M " + (show(v.value0.head.x) + (" " + (show(v.value0.head.y) + foldl(function (acc) {
            return function (p) {
                return acc + (" H " + (show(p.x) + (" V " + show(p.y))));
            };
        })("")(v.value0.tail))));
    };
    throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 651, column 3 - line 657, column 16): " + [ v.constructor.name ]);
};

// | Step before (vertical then horizontal)
var generateStepBeforePath = function (points) {
    var v = Data_Array.uncons(points);
    if (v instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v instanceof Data_Maybe.Just) {
        return "M " + (show(v.value0.head.x) + (" " + (show(v.value0.head.y) + foldl(function (acc) {
            return function (p) {
                return acc + (" V " + (show(p.y) + (" H " + show(p.x))));
            };
        })("")(v.value0.tail))));
    };
    throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 662, column 3 - line 668, column 16): " + [ v.constructor.name ]);
};

// | Linear interpolation (straight lines)
var generateLinearPath = function (points) {
    var v = Data_Array.uncons(points);
    if (v instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v instanceof Data_Maybe.Just) {
        return "M " + (show(v.value0.head.x) + (" " + (show(v.value0.head.y) + foldl(function (acc) {
            return function (p) {
                return acc + (" L " + (show(p.x) + (" " + show(p.y))));
            };
        })("")(v.value0.tail))));
    };
    throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 595, column 3 - line 599, column 76): " + [ v.constructor.name ]);
};

// | Generate fill path (closes the area to the bottom)
var generateFillPath = function (points) {
    return function (chartHeight) {
        return function (paddingTop) {
            var v = Data_Array.uncons(points);
            if (v instanceof Data_Maybe.Nothing) {
                return "";
            };
            if (v instanceof Data_Maybe.Just) {
                var linePath = generateLinearPath(points);
                var lastPoint = Data_Maybe.fromMaybe(v.value0.head)(Data_Array.last(points));
                var baseline = paddingTop + chartHeight;
                return linePath + (" L " + (show(lastPoint.x) + (" " + (show(baseline) + (" L " + (show(v.value0.head.x) + (" " + (show(baseline) + " Z"))))))));
            };
            throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 673, column 3 - line 684, column 13): " + [ v.constructor.name ]);
        };
    };
};

// | Cubic bezier smooth curves
var generateBezierPath = function (points) {
    var v = Data_Array.uncons(points);
    if (v instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v instanceof Data_Maybe.Just) {
        
        // Calculate control points for smooth bezier
var getControlPoints = function (p0) {
            return function (p1) {
                return function (p2) {
                    var d12 = {
                        x: p2.x - p1.x,
                        y: p2.y - p1.y
                    };
                    var d01 = {
                        x: p1.x - p0.x,
                        y: p1.y - p0.y
                    };
                    return {
                        c1: {
                            x: p1.x - d12.x * 0.3,
                            y: p1.y - d12.y * 0.3
                        },
                        c2: {
                            x: p1.x + d01.x * 0.3,
                            y: p1.y + d01.y * 0.3
                        }
                    };
                };
            };
        };
        
        // Build path with cubic bezier curves
var buildCurve = function (acc) {
            return function (curr) {
                var cp = getControlPoints(acc.prevPrev)(acc.prev)(curr);
                return {
                    path: acc.path + (" C " + (show(cp.c1.x) + (" " + (show(cp.c1.y) + (", " + (show(cp.c2.x) + (" " + (show(cp.c2.y) + (", " + (show(curr.x) + (" " + show(curr.y)))))))))))),
                    prev: curr,
                    prevPrev: acc.prev
                };
            };
        };
        var v1 = Data_Array.uncons(v.value0.tail);
        if (v1 instanceof Data_Maybe.Nothing) {
            return "M " + (show(v.value0.head.x) + (" " + show(v.value0.head.y)));
        };
        if (v1 instanceof Data_Maybe.Just) {
            var initial = {
                path: "M " + (show(v.value0.head.x) + (" " + (show(v.value0.head.y) + (" L " + (show(v1.value0.head.x) + (" " + show(v1.value0.head.y))))))),
                prev: v1.value0.head,
                prevPrev: v.value0.head
            };
            var result = foldl(buildCurve)(initial)(v1.value0.tail);
            return result.path;
        };
        throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 634, column 9 - line 646, column 26): " + [ v1.constructor.name ]);
    };
    throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 604, column 3 - line 646, column 26): " + [ v.constructor.name ]);
};

// | Generate SVG path based on curve type
var generatePath = function (cType) {
    return function (points) {
        if (cType instanceof Linear) {
            return generateLinearPath(points);
        };
        if (cType instanceof Bezier) {
            return generateBezierPath(points);
        };
        if (cType instanceof Step) {
            return generateStepPath(points);
        };
        if (cType instanceof StepBefore) {
            return generateStepBeforePath(points);
        };
        throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 586, column 3 - line 590, column 48): " + [ cType.constructor.name ]);
    };
};

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                     // helpers
// ═══════════════════════════════════════════════════════════════════════════════
// | Format number for display
var formatNumber = function (n) {
    var absN = Data_Number.abs(n);
    var $81 = absN >= 1000000.0;
    if ($81) {
        return show(n / 1000000.0) + "M";
    };
    var $82 = absN >= 1000.0;
    if ($82) {
        return show(n / 1000.0) + "K";
    };
    return show(n);
};

// | Line chart with full props
var lineChartWithProps = function (props) {
    var yMin = Data_Maybe.fromMaybe(0.0)(minimum(map(function (v) {
        return v.y;
    })(props.data)));
    var yMax = Data_Maybe.fromMaybe(1.0)(maximum(map(function (v) {
        return v.y;
    })(props.data)));
    var yRange = (function () {
        var $83 = yMax === yMin;
        if ($83) {
            return 1.0;
        };
        return yMax - yMin;
    })();
    
    // Calculate data bounds
var xMin = Data_Maybe.fromMaybe(0.0)(minimum(map(function (v) {
        return v.x;
    })(props.data)));
    var xMax = Data_Maybe.fromMaybe(1.0)(maximum(map(function (v) {
        return v.x;
    })(props.data)));
    var xRange = (function () {
        var $84 = xMax === xMin;
        if ($84) {
            return 1.0;
        };
        return xMax - xMin;
    })();
    
    // Gradient definition for fill
var gradientDef = (function () {
        if (props.fillColor instanceof Data_Maybe.Just) {
            return [ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("defs")([  ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("linearGradient")([ Halogen_HTML_Properties.attr("id")("lineChartGradient"), Halogen_HTML_Properties.attr("x1")("0%"), Halogen_HTML_Properties.attr("y1")("0%"), Halogen_HTML_Properties.attr("x2")("0%"), Halogen_HTML_Properties.attr("y2")("100%") ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("stop")([ Halogen_HTML_Properties.attr("offset")("0%"), Halogen_HTML_Properties.attr("stop-color")(props.fillColor.value0), Halogen_HTML_Properties.attr("stop-opacity")("0.3") ])([  ]), Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("stop")([ Halogen_HTML_Properties.attr("offset")("100%"), Halogen_HTML_Properties.attr("stop-color")(props.fillColor.value0), Halogen_HTML_Properties.attr("stop-opacity")("0.05") ])([  ]) ]) ]) ];
        };
        if (props.fillColor instanceof Data_Maybe.Nothing) {
            return [  ];
        };
        throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 291, column 19 - line 317, column 20): " + [ props.fillColor.constructor.name ]);
    })();
    var chartWidth = Data_Int.toNumber(props.width) - props.padding.left - props.padding.right;
    var chartHeight = Data_Int.toNumber(props.height) - props.padding.top - props.padding.bottom;
    
    // Grid lines
var gridLines = (function () {
        if (props.showGrid) {
            var vLineSpacing = chartWidth / Data_Int.toNumber(5);
            var vLines = Data_Array.mapWithIndex(function (idx) {
                return function (v) {
                    var x = props.padding.left + Data_Int.toNumber(idx) * vLineSpacing;
                    return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("line")([ Halogen_HTML_Properties.attr("x1")(show(x)), Halogen_HTML_Properties.attr("y1")(show(props.padding.top)), Halogen_HTML_Properties.attr("x2")(show(x)), Halogen_HTML_Properties.attr("y2")(show(props.padding.top + chartHeight)), Hydrogen_UI_Core.svgCls([ "stroke-muted-foreground/20" ]), Halogen_HTML_Properties.attr("stroke-dasharray")("4,4") ])([  ]);
                };
            })(Data_Array.replicate(5 + 1 | 0)(Data_Unit.unit));
            var hLineSpacing = chartHeight / Data_Int.toNumber(5);
            var hLines = Data_Array.mapWithIndex(function (idx) {
                return function (v) {
                    var y = props.padding.top + Data_Int.toNumber(idx) * hLineSpacing;
                    return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("line")([ Halogen_HTML_Properties.attr("x1")(show(props.padding.left)), Halogen_HTML_Properties.attr("y1")(show(y)), Halogen_HTML_Properties.attr("x2")(show(props.padding.left + chartWidth)), Halogen_HTML_Properties.attr("y2")(show(y)), Hydrogen_UI_Core.svgCls([ "stroke-muted-foreground/20" ]), Halogen_HTML_Properties.attr("stroke-dasharray")("4,4") ])([  ]);
                };
            })(Data_Array.replicate(5 + 1 | 0)(Data_Unit.unit));
            return append1(hLines)(vLines);
        };
        return [  ];
    })();
    
    // Scale data points to chart coordinates
var scalePoint = function (p) {
        return {
            x: props.padding.left + ((p.x - xMin) / xRange) * chartWidth,
            y: props.padding.top + (1.0 - (p.y - yMin) / yRange) * chartHeight
        };
    };
    var scaledPoints = map(scalePoint)(props.data);
    
    // Data point dots
var dots = (function () {
        if (props.showDots) {
            return map(function (p) {
                return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("circle")([ Halogen_HTML_Properties.attr("cx")(show(p.x)), Halogen_HTML_Properties.attr("cy")(show(p.y)), Halogen_HTML_Properties.attr("r")(show(props.dotRadius)), Halogen_HTML_Properties.attr("fill")(props.strokeColor), Hydrogen_UI_Core.svgCls([ "cursor-pointer hover:r-6 transition-all" ]) ])([  ]);
            })(scaledPoints);
        };
        return [  ];
    })();
    
    // Generate fill path if needed
var fillPathData = (function () {
        if (props.fillColor instanceof Data_Maybe.Just) {
            return generateFillPath(scaledPoints)(chartHeight)(props.padding.top);
        };
        if (props.fillColor instanceof Data_Maybe.Nothing) {
            return "";
        };
        throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 286, column 20 - line 288, column 20): " + [ props.fillColor.constructor.name ]);
    })();
    
    // Fill area
var fillArea = (function () {
        if (props.fillColor instanceof Data_Maybe.Just) {
            return [ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("path")([ Halogen_HTML_Properties.attr("d")(fillPathData), Halogen_HTML_Properties.attr("fill")("url(#lineChartGradient)"), Hydrogen_UI_Core.svgCls([ (function () {
                if (props.animated) {
                    return "animate-fade-in";
                };
                return "";
            })() ]) ])([  ]) ];
        };
        if (props.fillColor instanceof Data_Maybe.Nothing) {
            return [  ];
        };
        throw new Error("Failed pattern match at Hydrogen.Chart.LineChart (line 320, column 16 - line 329, column 20): " + [ props.fillColor.constructor.name ]);
    })();
    
    // Generate path based on curve type
var pathData = generatePath(props.curveType)(scaledPoints);
    
    // Line path
var linePath = [ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("path")([ Halogen_HTML_Properties.attr("d")(pathData), Halogen_HTML_Properties.attr("fill")("none"), Halogen_HTML_Properties.attr("stroke")(props.strokeColor), Halogen_HTML_Properties.attr("stroke-width")(show(props.strokeWidth)), Halogen_HTML_Properties.attr("stroke-linecap")("round"), Halogen_HTML_Properties.attr("stroke-linejoin")("round"), Hydrogen_UI_Core.svgCls([ (function () {
        if (props.animated) {
            return "animate-draw-line";
        };
        return "";
    })() ]) ])([  ]) ];
    
    // X-axis labels
var xAxisLabels = (function () {
        if (props.showAxisLabels) {
            var valueSpacing = xRange / Data_Int.toNumber(5);
            var labelSpacing = chartWidth / Data_Int.toNumber(5);
            return Data_Array.mapWithIndex(function (idx) {
                return function (v) {
                    var x = props.padding.left + Data_Int.toNumber(idx) * labelSpacing;
                    var val = xMin + Data_Int.toNumber(idx) * valueSpacing;
                    return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("text")([ Halogen_HTML_Properties.attr("x")(show(x)), Halogen_HTML_Properties.attr("y")(show(props.padding.top + chartHeight + 20.0)), Halogen_HTML_Properties.attr("text-anchor")("middle"), Hydrogen_UI_Core.svgCls([ "fill-muted-foreground text-xs" ]) ])([ Halogen_HTML_Core.text(formatNumber(val)) ]);
                };
            })(Data_Array.replicate(5 + 1 | 0)(Data_Unit.unit));
        };
        return [  ];
    })();
    
    // Y-axis labels
var yAxisLabels = (function () {
        if (props.showAxisLabels) {
            var valueSpacing = yRange / Data_Int.toNumber(5);
            var labelSpacing = chartHeight / Data_Int.toNumber(5);
            return Data_Array.mapWithIndex(function (idx) {
                return function (v) {
                    var y = props.padding.top + Data_Int.toNumber(5 - idx | 0) * labelSpacing;
                    var val = yMin + Data_Int.toNumber(idx) * valueSpacing;
                    return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("text")([ Halogen_HTML_Properties.attr("x")(show(props.padding.left - 8.0)), Halogen_HTML_Properties.attr("y")(show(y + 4.0)), Halogen_HTML_Properties.attr("text-anchor")("end"), Hydrogen_UI_Core.svgCls([ "fill-muted-foreground text-xs" ]) ])([ Halogen_HTML_Core.text(formatNumber(val)) ]);
                };
            })(Data_Array.replicate(5 + 1 | 0)(Data_Unit.unit));
        };
        return [  ];
    })();
    return Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "relative", props.className ]) ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("svg")([ Hydrogen_UI_Core.svgCls([ "w-full h-auto" ]), Halogen_HTML_Properties.attr("viewBox")("0 0 " + (show1(props.width) + (" " + show1(props.height)))), Halogen_HTML_Properties.attr("preserveAspectRatio")("xMidYMid meet") ])(append1(gradientDef)(append1(gridLines)(append1(yAxisLabels)(append1(xAxisLabels)(append1(fillArea)(append1(linePath)(dots))))))) ]);
};

// | Set fill color (for area chart effect)
var fillColor = function (c) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            fillColor: c
        };
    };
};
var eqCurveType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Linear && y instanceof Linear) {
                return true;
            };
            if (x instanceof Bezier && y instanceof Bezier) {
                return true;
            };
            if (x instanceof Step && y instanceof Step) {
                return true;
            };
            if (x instanceof StepBefore && y instanceof StepBefore) {
                return true;
            };
            return false;
        };
    }
};

// | Set data point dot radius
var dotRadius = function (r) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            padding: props.padding,
            className: props.className,
            dotRadius: r
        };
    };
};

// | Default line chart properties
var defaultProps = /* #__PURE__ */ (function () {
    return {
        data: [  ],
        width: 400,
        height: 300,
        curveType: Bezier.value,
        showDots: true,
        showGrid: true,
        showTooltip: true,
        showLegend: false,
        showCrosshair: false,
        showAxisLabels: true,
        animated: true,
        strokeColor: "#3b82f6",
        fillColor: Data_Maybe.Nothing.value,
        strokeWidth: 2.0,
        dotRadius: 4.0,
        padding: {
            top: 20.0,
            right: 20.0,
            bottom: 40.0,
            left: 50.0
        },
        className: ""
    };
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                  // line chart
// ═══════════════════════════════════════════════════════════════════════════════
// | Simple line chart with basic config
var lineChart = function (config) {
    return lineChartWithProps({
        curveType: defaultProps.curveType,
        showDots: defaultProps.showDots,
        showGrid: defaultProps.showGrid,
        showTooltip: defaultProps.showTooltip,
        showLegend: defaultProps.showLegend,
        showCrosshair: defaultProps.showCrosshair,
        showAxisLabels: defaultProps.showAxisLabels,
        animated: defaultProps.animated,
        strokeColor: defaultProps.strokeColor,
        fillColor: defaultProps.fillColor,
        strokeWidth: defaultProps.strokeWidth,
        dotRadius: defaultProps.dotRadius,
        padding: defaultProps.padding,
        className: defaultProps.className,
        data: config.data,
        width: config.width,
        height: config.height
    });
};

// | Multi-series line chart
var multiLineChart = function (config) {
    
    // Legend
var legend = map(function (s) {
        return Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "flex items-center gap-2" ]) ])([ Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "w-4 h-0.5" ]), Halogen_HTML_Properties.style("background-color: " + s.color) ])([  ]), Halogen_HTML_Elements.span([ Hydrogen_UI_Core.cls([ "text-xs text-muted-foreground" ]) ])([ Halogen_HTML_Core.text(s.label) ]) ]);
    })(config.series);
    var chartWidth = Data_Int.toNumber(config.width) - defaultProps.padding.left - defaultProps.padding.right;
    var chartHeight = Data_Int.toNumber(config.height) - defaultProps.padding.top - defaultProps.padding.bottom;
    
    // Grid lines
var gridLines = (function () {
        var hLineSpacing = chartHeight / Data_Int.toNumber(5);
        return Data_Array.mapWithIndex(function (idx) {
            return function (v) {
                var y = defaultProps.padding.top + Data_Int.toNumber(idx) * hLineSpacing;
                return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("line")([ Halogen_HTML_Properties.attr("x1")(show(defaultProps.padding.left)), Halogen_HTML_Properties.attr("y1")(show(y)), Halogen_HTML_Properties.attr("x2")(show(defaultProps.padding.left + chartWidth)), Halogen_HTML_Properties.attr("y2")(show(y)), Hydrogen_UI_Core.svgCls([ "stroke-muted-foreground/20" ]), Halogen_HTML_Properties.attr("stroke-dasharray")("4,4") ])([  ]);
            };
        })(Data_Array.replicate(5 + 1 | 0)(Data_Unit.unit));
    })();
    
    // Calculate global data bounds across all series
var allPoints = bind(config.series)(function (v) {
        return v.data;
    });
    var xMax = Data_Maybe.fromMaybe(1.0)(maximum(map(function (v) {
        return v.x;
    })(allPoints)));
    var xMin = Data_Maybe.fromMaybe(0.0)(minimum(map(function (v) {
        return v.x;
    })(allPoints)));
    var xRange = (function () {
        var $99 = xMax === xMin;
        if ($99) {
            return 1.0;
        };
        return xMax - xMin;
    })();
    var yMax = Data_Maybe.fromMaybe(1.0)(maximum(map(function (v) {
        return v.y;
    })(allPoints)));
    var yMin = Data_Maybe.fromMaybe(0.0)(minimum(map(function (v) {
        return v.y;
    })(allPoints)));
    var yRange = (function () {
        var $100 = yMax === yMin;
        if ($100) {
            return 1.0;
        };
        return yMax - yMin;
    })();
    
    // Scale function
var scalePoint = function (p) {
        return {
            x: defaultProps.padding.left + ((p.x - xMin) / xRange) * chartWidth,
            y: defaultProps.padding.top + (1.0 - (p.y - yMin) / yRange) * chartHeight
        };
    };
    
    // Generate lines for each series
var seriesLines = map(function (s) {
        var scaledPoints = map(scalePoint)(s.data);
        var pathData = generatePath(defaultProps.curveType)(scaledPoints);
        return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("g")([ Hydrogen_UI_Core.svgCls([ "series-line" ]) ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("path")([ Halogen_HTML_Properties.attr("d")(pathData), Halogen_HTML_Properties.attr("fill")("none"), Halogen_HTML_Properties.attr("stroke")(s.color), Halogen_HTML_Properties.attr("stroke-width")(show(defaultProps.strokeWidth)), Halogen_HTML_Properties.attr("stroke-linecap")("round"), Halogen_HTML_Properties.attr("stroke-linejoin")("round") ])([  ]) ]);
    })(config.series);
    return Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "relative" ]) ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("svg")([ Hydrogen_UI_Core.svgCls([ "w-full h-auto" ]), Halogen_HTML_Properties.attr("viewBox")("0 0 " + (show1(config.width) + (" " + show1(config.height)))), Halogen_HTML_Properties.attr("preserveAspectRatio")("xMidYMid meet") ])(append1(gridLines)(seriesLines)), Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "flex flex-wrap gap-4 justify-center mt-4" ]) ])(legend) ]);
};

// | Set curve interpolation type
var curveType = function (c) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            curveType: c
        };
    };
};

// | Add custom class
var className = function (c) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className + (" " + c)
        };
    };
};

// | Area chart (line chart with fill)
var areaChart = function (config) {
    return lineChartWithProps({
        curveType: defaultProps.curveType,
        showDots: defaultProps.showDots,
        showGrid: defaultProps.showGrid,
        showTooltip: defaultProps.showTooltip,
        showLegend: defaultProps.showLegend,
        showCrosshair: defaultProps.showCrosshair,
        showAxisLabels: defaultProps.showAxisLabels,
        animated: defaultProps.animated,
        strokeWidth: defaultProps.strokeWidth,
        dotRadius: defaultProps.dotRadius,
        padding: defaultProps.padding,
        className: defaultProps.className,
        data: config.data,
        width: config.width,
        height: config.height,
        strokeColor: config.color,
        fillColor: new Data_Maybe.Just(config.color)
    });
};

// | Enable/disable animation
var animated = function (v) {
    return function (props) {
        return {
            data: props.data,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showDots: props.showDots,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showCrosshair: props.showCrosshair,
            showAxisLabels: props.showAxisLabels,
            strokeColor: props.strokeColor,
            fillColor: props.fillColor,
            strokeWidth: props.strokeWidth,
            dotRadius: props.dotRadius,
            padding: props.padding,
            className: props.className,
            animated: v
        };
    };
};
export {
    lineChart,
    lineChartWithProps,
    defaultProps,
    areaChart,
    multiLineChart,
    Linear,
    Bezier,
    Step,
    StepBefore,
    curveType,
    showDots,
    showGrid,
    showTooltip,
    showLegend,
    showCrosshair,
    showAxisLabels,
    animated,
    strokeColor,
    fillColor,
    strokeWidth,
    dotRadius,
    className,
    eqCurveType
};
