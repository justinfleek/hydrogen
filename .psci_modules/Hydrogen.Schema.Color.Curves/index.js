import * as Data_Array from "../Data.Array/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Monoid from "../Data.Monoid/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Hydrogen_Schema_Color_Channel from "../Hydrogen.Schema.Color.Channel/index.js";
import * as Hydrogen_Schema_Color_RGB from "../Hydrogen.Schema.Color.RGB/index.js";
var outputIsSymbol = {
    reflectSymbol: function () {
        return "output";
    }
};
var inputIsSymbol = {
    reflectSymbol: function () {
        return "input";
    }
};
var eqRec = /* #__PURE__ */ Data_Eq.eqRec();
var eqRowCons = /* #__PURE__ */ Data_Eq.eqRowCons(Data_Eq.eqRowNil)();
var compare = /* #__PURE__ */ Data_Ord.compare(Data_Ord.ordInt);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);

// ═══════════════════════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════════════════════
// Single point on a curve (input/output mapping)
// Input and output are both 0-255 (Channel values)
var CurvePoint = function (x) {
    return x;
};

// A curve is a sorted array of control points
// Interpolation happens between points using cubic Bezier
var Curve = function (x) {
    return x;
};

// Complete curves configuration for color grading
// Master curve affects all channels, individual curves affect specific channels
var Curves = function (x) {
    return x;
};
var semigroupCurve = Data_Semigroup.semigroupArray;
var ordCurvePoint = /* #__PURE__ */ Data_Ord.ordRecord()(/* #__PURE__ */ Data_Ord.ordRecordCons(/* #__PURE__ */ Data_Ord.ordRecordCons(Data_Ord.ordRecordNil)()(outputIsSymbol)(Hydrogen_Schema_Color_Channel.ordChannel))()(inputIsSymbol)(Hydrogen_Schema_Color_Channel.ordChannel));
var monoidCurve = Data_Monoid.monoidArray;
var eqCurvePoint = /* #__PURE__ */ eqRec(/* #__PURE__ */ Data_Eq.eqRowCons(/* #__PURE__ */ eqRowCons(outputIsSymbol)(Hydrogen_Schema_Color_Channel.eqChannel))()(inputIsSymbol)(Hydrogen_Schema_Color_Channel.eqChannel));
var eqCurve = /* #__PURE__ */ Data_Eq.eqArray(eqCurvePoint);
var eqCurves = /* #__PURE__ */ eqRec(/* #__PURE__ */ Data_Eq.eqRowCons(/* #__PURE__ */ Data_Eq.eqRowCons(/* #__PURE__ */ Data_Eq.eqRowCons(/* #__PURE__ */ eqRowCons({
    reflectSymbol: function () {
        return "red";
    }
})(eqCurve))()({
    reflectSymbol: function () {
        return "master";
    }
})(eqCurve))()({
    reflectSymbol: function () {
        return "green";
    }
})(eqCurve))()({
    reflectSymbol: function () {
        return "blue";
    }
})(eqCurve));

// Find next segment recursively
var findNext = function ($copy_inputVal) {
    return function ($copy_prev) {
        return function ($copy_points) {
            var $tco_var_inputVal = $copy_inputVal;
            var $tco_var_prev = $copy_prev;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(inputVal, prev, points) {
                var v = Data_Array.uncons(points);
                if (v instanceof Data_Maybe.Nothing) {
                    $tco_done = true;
                    return Data_Maybe.Nothing.value;
                };
                if (v instanceof Data_Maybe.Just) {
                    var currInput = Data_Int.toNumber(Hydrogen_Schema_Color_Channel.unwrap(v.value0.head.input));
                    var $67 = inputVal <= currInput;
                    if ($67) {
                        $tco_done = true;
                        return new Data_Maybe.Just({
                            before: prev,
                            after: v.value0.head
                        });
                    };
                    $tco_var_inputVal = inputVal;
                    $tco_var_prev = v.value0.head;
                    $copy_points = v.value0.tail;
                    return;
                };
                throw new Error("Failed pattern match at Hydrogen.Schema.Color.Curves (line 129, column 3 - line 136, column 44): " + [ v.constructor.name ]);
            };
            while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_inputVal, $tco_var_prev, $copy_points);
            };
            return $tco_result;
        };
    };
};

// Find the segment containing the input value
var findSegment = function (inputVal) {
    return function (points) {
        var v = Data_Array.uncons(points);
        if (v instanceof Data_Maybe.Nothing) {
            return Data_Maybe.Nothing.value;
        };
        if (v instanceof Data_Maybe.Just) {
            var $73 = inputVal <= Data_Int.toNumber(Hydrogen_Schema_Color_Channel.unwrap(v.value0.head.input));
            if ($73) {
                var v1 = Data_Array.uncons(v.value0.tail);
                if (v1 instanceof Data_Maybe.Nothing) {
                    return Data_Maybe.Nothing.value;
                };
                if (v1 instanceof Data_Maybe.Just) {
                    return new Data_Maybe.Just({
                        before: v.value0.head,
                        after: v1.value0.head
                    });
                };
                throw new Error("Failed pattern match at Hydrogen.Schema.Color.Curves (line 121, column 14 - line 123, column 73): " + [ v1.constructor.name ]);
            };
            return findNext(inputVal)(v.value0.head)(v.value0.tail);
        };
        throw new Error("Failed pattern match at Hydrogen.Schema.Color.Curves (line 117, column 3 - line 124, column 42): " + [ v.constructor.name ]);
    };
};

// Create a complete curves configuration
var curves = function (master) {
    return function (red) {
        return function (green) {
            return function (blue) {
                return {
                    master: master,
                    red: red,
                    green: green,
                    blue: blue
                };
            };
        };
    };
};

// ═══════════════════════════════════════════════════════════════════════════════
// SMART CONSTRUCTORS
// ═══════════════════════════════════════════════════════════════════════════════
// Create a curve point
var curvePoint = function (input) {
    return function (output) {
        return {
            input: input,
            output: output
        };
    };
};

// Create a curve from control points (automatically sorts by input)
var curve = function (points) {
    var comparePoints = function (v) {
        return function (v1) {
            return compare(Hydrogen_Schema_Color_Channel.unwrap(v.input))(Hydrogen_Schema_Color_Channel.unwrap(v1.input));
        };
    };
    return Data_Array.sortBy(comparePoints)(points);
};

// Linear curve (identity - no adjustment)
var linearCurve = /* #__PURE__ */ curve([ /* #__PURE__ */ curvePoint(/* #__PURE__ */ Hydrogen_Schema_Color_Channel.channel(0))(/* #__PURE__ */ Hydrogen_Schema_Color_Channel.channel(0)), /* #__PURE__ */ curvePoint(/* #__PURE__ */ Hydrogen_Schema_Color_Channel.channel(255))(/* #__PURE__ */ Hydrogen_Schema_Color_Channel.channel(255)) ]);

// Contrast curve (S-curve - darken shadows, brighten highlights)
var contrastCurve = function (amount) {
    return curve([ curvePoint(Hydrogen_Schema_Color_Channel.channel(0))(Hydrogen_Schema_Color_Channel.channel(0)), curvePoint(Hydrogen_Schema_Color_Channel.channel(64))(Hydrogen_Schema_Color_Channel.channel(Data_Int.round(max(0.0)(min(255.0)(64.0 - amount * 10.0))))), curvePoint(Hydrogen_Schema_Color_Channel.channel(128))(Hydrogen_Schema_Color_Channel.channel(128)), curvePoint(Hydrogen_Schema_Color_Channel.channel(192))(Hydrogen_Schema_Color_Channel.channel(Data_Int.round(max(0.0)(min(255.0)(192.0 + amount * 10.0))))), curvePoint(Hydrogen_Schema_Color_Channel.channel(255))(Hydrogen_Schema_Color_Channel.channel(255)) ]);
};

// ═══════════════════════════════════════════════════════════════════════════════
// CURVE INTERPOLATION
// ═══════════════════════════════════════════════════════════════════════════════
// Apply curve to a single channel value
// Uses linear interpolation between control points
var applyToChannel = function (v) {
    return function (input) {
        var inputVal = Data_Int.toNumber(Hydrogen_Schema_Color_Channel.unwrap(input));
        var v1 = findSegment(inputVal)(v);
        if (v1 instanceof Data_Maybe.Nothing) {
            return input;
        };
        if (v1 instanceof Data_Maybe.Just) {
            var y2 = Data_Int.toNumber(Hydrogen_Schema_Color_Channel.unwrap(v1.value0.after.output));
            var y1 = Data_Int.toNumber(Hydrogen_Schema_Color_Channel.unwrap(v1.value0.before.output));
            var x2 = Data_Int.toNumber(Hydrogen_Schema_Color_Channel.unwrap(v1.value0.after.input));
            var x1 = Data_Int.toNumber(Hydrogen_Schema_Color_Channel.unwrap(v1.value0.before.input));
            
            // Linear interpolation
var t = (function () {
                var $87 = x2 === x1;
                if ($87) {
                    return 0.0;
                };
                return (inputVal - x1) / (x2 - x1);
            })();
            var output = y1 + t * (y2 - y1);
            return Hydrogen_Schema_Color_Channel.channel(Data_Int.round(output));
        };
        throw new Error("Failed pattern match at Hydrogen.Schema.Color.Curves (line 100, column 6 - line 112, column 32): " + [ v1.constructor.name ]);
    };
};

// ═══════════════════════════════════════════════════════════════════════════════
// RGB APPLICATION
// ═══════════════════════════════════════════════════════════════════════════════
// Apply curves to an RGB color
// Master curve is applied first, then individual channel curves
var applyToRgb = function (v) {
    return function (rgb) {
        var rMaster = applyToChannel(v.master)(Hydrogen_Schema_Color_RGB.red(rgb));
        
        // Apply individual channel curves
var rFinal = applyToChannel(v.red)(rMaster);
        var gMaster = applyToChannel(v.master)(Hydrogen_Schema_Color_RGB.green(rgb));
        var gFinal = applyToChannel(v.green)(gMaster);
        var bMaster = applyToChannel(v.master)(Hydrogen_Schema_Color_RGB.blue(rgb));
        var bFinal = applyToChannel(v.blue)(bMaster);
        return Hydrogen_Schema_Color_RGB.rgbFromChannels(rFinal)(gFinal)(bFinal);
    };
};
export {
    curve,
    curvePoint,
    curves,
    linearCurve,
    contrastCurve,
    applyToRgb,
    applyToChannel,
    eqCurvePoint,
    ordCurvePoint,
    eqCurve,
    semigroupCurve,
    monoidCurve,
    eqCurves
};
