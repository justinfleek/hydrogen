// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//                                                        // hydrogen // gesture
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// | Touch and mouse gesture recognition
// |
// | Unified gesture system supporting touch, mouse, and pointer events
// | with velocity tracking and gesture composition.
// |
// | ## Usage
// |
// | ```purescript
// | import Hydrogen.Motion.Gesture as G
// |
// | -- Create a pan gesture recognizer
// | panGesture <- G.createPanGesture element
// |   { onStart: \state -> Console.log "Pan started"
// |   , onMove: \state -> Console.log $ "Moving: " <> show state.delta
// |   , onEnd: \state -> Console.log "Pan ended"
// |   , threshold: 10.0
// |   }
// |
// | -- Create a pinch gesture for zooming
// | pinchGesture <- G.createPinchGesture element
// |   { onPinch: \state -> setScale state.scale
// |   , onEnd: \state -> commitScale state.scale
// |   }
// |
// | -- Swipe gesture with direction
// | swipeGesture <- G.createSwipeGesture element
// |   { onSwipe: \dir -> case dir of
// |       G.SwipeLeft -> prevSlide
// |       G.SwipeRight -> nextSlide
// |       _ -> pure unit
// |   , velocityThreshold: 0.5
// |   }
// |
// | -- Compose gestures
// | G.composeGestures [panGesture, pinchGesture]
// |
// | -- Clean up
// | G.destroyGesture panGesture
// | ```
import * as $foreign from "./foreign.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect from "../Effect/index.js";
import * as Effect_Ref from "../Effect.Ref/index.js";
var pure = /* #__PURE__ */ Control_Applicative.pure(Effect.applicativeEffect);

// | Swipe direction
var SwipeLeft = /* #__PURE__ */ (function () {
    function SwipeLeft() {

    };
    SwipeLeft.value = new SwipeLeft();
    return SwipeLeft;
})();

// | Swipe direction
var SwipeRight = /* #__PURE__ */ (function () {
    function SwipeRight() {

    };
    SwipeRight.value = new SwipeRight();
    return SwipeRight;
})();

// | Swipe direction
var SwipeUp = /* #__PURE__ */ (function () {
    function SwipeUp() {

    };
    SwipeUp.value = new SwipeUp();
    return SwipeUp;
})();

// | Swipe direction
var SwipeDown = /* #__PURE__ */ (function () {
    function SwipeDown() {

    };
    SwipeDown.value = new SwipeDown();
    return SwipeDown;
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                       // types
// ═══════════════════════════════════════════════════════════════════════════════
// | Gesture lifecycle state
var Idle = /* #__PURE__ */ (function () {
    function Idle() {

    };
    Idle.value = new Idle();
    return Idle;
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                       // types
// ═══════════════════════════════════════════════════════════════════════════════
// | Gesture lifecycle state
var Active = /* #__PURE__ */ (function () {
    function Active() {

    };
    Active.value = new Active();
    return Active;
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                       // types
// ═══════════════════════════════════════════════════════════════════════════════
// | Gesture lifecycle state
var Ended = /* #__PURE__ */ (function () {
    function Ended() {

    };
    Ended.value = new Ended();
    return Ended;
})();
var trackPoint = function (tracker) {
    return function (point) {
        return $foreign.trackPointImpl(tracker.points)(tracker.maxSamples)(point);
    };
};
var swipeDirectionFromString = function (v) {
    if (v === "left") {
        return new Data_Maybe.Just(SwipeLeft.value);
    };
    if (v === "right") {
        return new Data_Maybe.Just(SwipeRight.value);
    };
    if (v === "up") {
        return new Data_Maybe.Just(SwipeUp.value);
    };
    if (v === "down") {
        return new Data_Maybe.Just(SwipeDown.value);
    };
    return Data_Maybe.Nothing.value;
};
var showSwipeDirection = {
    show: function (v) {
        if (v instanceof SwipeLeft) {
            return "SwipeLeft";
        };
        if (v instanceof SwipeRight) {
            return "SwipeRight";
        };
        if (v instanceof SwipeUp) {
            return "SwipeUp";
        };
        if (v instanceof SwipeDown) {
            return "SwipeDown";
        };
        throw new Error("Failed pattern match at Hydrogen.Motion.Gesture (line 393, column 1 - line 397, column 31): " + [ v.constructor.name ]);
    }
};
var showGestureState = {
    show: function (v) {
        if (v instanceof Idle) {
            return "Idle";
        };
        if (v instanceof Active) {
            return "Active";
        };
        if (v instanceof Ended) {
            return "Ended";
        };
        throw new Error("Failed pattern match at Hydrogen.Motion.Gesture (line 118, column 1 - line 121, column 23): " + [ v.constructor.name ]);
    }
};
var rotateStateFromJS = function (js) {
    var stateFromString = function (v) {
        if (v === "active") {
            return Active.value;
        };
        if (v === "ended") {
            return Ended.value;
        };
        return Idle.value;
    };
    return {
        state: stateFromString(js.state),
        rotation: js.rotation,
        initialRotation: js.initialRotation,
        center: {
            x: js.centerX,
            y: js.centerY
        },
        velocity: js.velocity
    };
};

// | Reset the velocity tracker
var resetTracker = function (tracker) {
    return Effect_Ref.write([  ])(tracker.points);
};
var pinchStateFromJS = function (js) {
    var stateFromString = function (v) {
        if (v === "active") {
            return Active.value;
        };
        if (v === "ended") {
            return Ended.value;
        };
        return Idle.value;
    };
    return {
        state: stateFromString(js.state),
        scale: js.scale,
        initialScale: js.initialScale,
        center: {
            x: js.centerX,
            y: js.centerY
        },
        distance: js.distance
    };
};
var panStateFromJS = function (js) {
    var stateFromString = function (v) {
        if (v === "active") {
            return Active.value;
        };
        if (v === "ended") {
            return Ended.value;
        };
        return Idle.value;
    };
    return {
        state: stateFromString(js.state),
        start: {
            x: js.startX,
            y: js.startY
        },
        current: {
            x: js.currentX,
            y: js.currentY
        },
        delta: {
            x: js.deltaX,
            y: js.deltaY
        },
        offset: {
            x: js.offsetX,
            y: js.offsetY
        },
        velocity: {
            vx: js.velocityX,
            vy: js.velocityY
        }
    };
};
var getVelocity = function (tracker) {
    return $foreign.getVelocityImpl(tracker.points);
};
var eqSwipeDirection = {
    eq: function (x) {
        return function (y) {
            if (x instanceof SwipeLeft && y instanceof SwipeLeft) {
                return true;
            };
            if (x instanceof SwipeRight && y instanceof SwipeRight) {
                return true;
            };
            if (x instanceof SwipeUp && y instanceof SwipeUp) {
                return true;
            };
            if (x instanceof SwipeDown && y instanceof SwipeDown) {
                return true;
            };
            return false;
        };
    }
};
var eqGestureState = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Idle && y instanceof Idle) {
                return true;
            };
            if (x instanceof Active && y instanceof Active) {
                return true;
            };
            if (x instanceof Ended && y instanceof Ended) {
                return true;
            };
            return false;
        };
    }
};

// | Default swipe configuration
var defaultSwipeConfig = {
    onSwipe: function (v) {
        return pure(Data_Unit.unit);
    },
    velocityThreshold: 0.5,
    distanceThreshold: 50.0,
    maxDuration: 300.0
};

// | Default rotate configuration
var defaultRotateConfig = {
    onStart: function (v) {
        return pure(Data_Unit.unit);
    },
    onRotate: function (v) {
        return pure(Data_Unit.unit);
    },
    onEnd: function (v) {
        return pure(Data_Unit.unit);
    },
    threshold: 0.0
};

// | Default pinch configuration
var defaultPinchConfig = {
    onStart: function (v) {
        return pure(Data_Unit.unit);
    },
    onPinch: function (v) {
        return pure(Data_Unit.unit);
    },
    onEnd: function (v) {
        return pure(Data_Unit.unit);
    },
    minScale: 0.1,
    maxScale: 10.0
};

// | Default pan configuration
var defaultPanConfig = {
    onStart: function (v) {
        return pure(Data_Unit.unit);
    },
    onMove: function (v) {
        return pure(Data_Unit.unit);
    },
    onEnd: function (v) {
        return pure(Data_Unit.unit);
    },
    threshold: 0.0,
    lockAxis: false,
    preventScroll: true
};

// | Default long press configuration
var defaultLongPressConfig = {
    onLongPress: function (v) {
        return pure(Data_Unit.unit);
    },
    onStart: function (v) {
        return pure(Data_Unit.unit);
    },
    onCancel: /* #__PURE__ */ pure(Data_Unit.unit),
    duration: 500.0,
    maxDistance: 10.0
};

// | Default double tap configuration
var defaultDoubleTapConfig = {
    onDoubleTap: function (v) {
        return pure(Data_Unit.unit);
    },
    onSingleTap: function (v) {
        return pure(Data_Unit.unit);
    },
    maxDelay: 300.0,
    maxDistance: 40.0
};

// | Create a velocity tracker
var createVelocityTracker = function (maxSamples) {
    return function __do() {
        var points = Effect_Ref["new"]([  ])();
        return {
            points: points,
            maxSamples: maxSamples
        };
    };
};
var createSwipeGesture = function (element) {
    return function (config) {
        var unwrapMs = function (v) {
            return v;
        };
        return $foreign.createSwipeGestureImpl(element)({
            onSwipe: function (dir) {
                var v = swipeDirectionFromString(dir);
                if (v instanceof Data_Maybe.Just) {
                    return config.onSwipe(v.value0);
                };
                if (v instanceof Data_Maybe.Nothing) {
                    return pure(Data_Unit.unit);
                };
                throw new Error("Failed pattern match at Hydrogen.Motion.Gesture (line 435, column 24 - line 437, column 29): " + [ v.constructor.name ]);
            },
            velocityThreshold: config.velocityThreshold,
            distanceThreshold: config.distanceThreshold,
            maxDuration: unwrapMs(config.maxDuration)
        });
    };
};
var createRotateGesture = function (element) {
    return function (config) {
        return $foreign.createRotateGestureImpl(element)({
            onStart: function (js) {
                return config.onStart(rotateStateFromJS(js));
            },
            onRotate: function (js) {
                return config.onRotate(rotateStateFromJS(js));
            },
            onEnd: function (js) {
                return config.onEnd(rotateStateFromJS(js));
            },
            threshold: config.threshold
        });
    };
};
var createPinchGesture = function (element) {
    return function (config) {
        return $foreign.createPinchGestureImpl(element)({
            onStart: function (js) {
                return config.onStart(pinchStateFromJS(js));
            },
            onPinch: function (js) {
                return config.onPinch(pinchStateFromJS(js));
            },
            onEnd: function (js) {
                return config.onEnd(pinchStateFromJS(js));
            },
            minScale: config.minScale,
            maxScale: config.maxScale
        });
    };
};
var createPanGesture = function (element) {
    return function (config) {
        return $foreign.createPanGestureImpl(element)({
            onStart: function (js) {
                return config.onStart(panStateFromJS(js));
            },
            onMove: function (js) {
                return config.onMove(panStateFromJS(js));
            },
            onEnd: function (js) {
                return config.onEnd(panStateFromJS(js));
            },
            threshold: config.threshold,
            lockAxis: config.lockAxis,
            preventScroll: config.preventScroll
        });
    };
};
var createLongPressGesture = function (element) {
    return function (config) {
        var unwrapMs = function (v) {
            return v;
        };
        return $foreign.createLongPressGestureImpl(element)({
            onLongPress: config.onLongPress,
            onStart: config.onStart,
            onCancel: config.onCancel,
            duration: unwrapMs(config.duration),
            maxDistance: config.maxDistance
        });
    };
};
var createDoubleTapGesture = function (element) {
    return function (config) {
        var unwrapMs = function (v) {
            return v;
        };
        return $foreign.createDoubleTapGestureImpl(element)({
            onDoubleTap: config.onDoubleTap,
            onSingleTap: config.onSingleTap,
            maxDelay: unwrapMs(config.maxDelay),
            maxDistance: config.maxDistance
        });
    };
};
export {
    composeGestures,
    enableGesture,
    disableGesture,
    destroyGesture
} from "./foreign.js";
export {
    Idle,
    Active,
    Ended,
    createPanGesture,
    defaultPanConfig,
    createPinchGesture,
    defaultPinchConfig,
    createRotateGesture,
    defaultRotateConfig,
    SwipeLeft,
    SwipeRight,
    SwipeUp,
    SwipeDown,
    createSwipeGesture,
    defaultSwipeConfig,
    createLongPressGesture,
    defaultLongPressConfig,
    createDoubleTapGesture,
    defaultDoubleTapConfig,
    createVelocityTracker,
    trackPoint,
    getVelocity,
    resetTracker,
    eqGestureState,
    showGestureState,
    eqSwipeDirection,
    showSwipeDirection
};
