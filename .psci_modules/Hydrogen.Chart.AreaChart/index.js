// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//                                                      // hydrogen // areachart
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// | Stacked Area chart component
// |
// | SVG-based stacked area and stream graph charts.
// |
// | ## Usage
// |
// | ```purescript
// | import Hydrogen.Chart.AreaChart as AreaChart
// |
// | -- Stacked area chart
// | AreaChart.stackedAreaChart
// |   { series: [ { label: "Desktop", data: desktopData, color: "#3b82f6" }
// |             , { label: "Mobile", data: mobileData, color: "#10b981" }
// |             , { label: "Tablet", data: tabletData, color: "#f59e0b" }
// |             ]
// |   , width: 400
// |   , height: 300
// |   }
// |
// | -- Stream graph (centered stacked areas)
// | AreaChart.streamGraph
// |   { series: streamData
// |   , width: 400
// |   , height: 300
// |   }
// |
// | -- With custom configuration
// | AreaChart.stackedAreaChartWithProps
// |   defaultProps
// |     { series = mySeries
// |     , showTooltip = true
// |     , showLegend = true
// |     , curveType = Bezier
// |     }
// | ```
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Halogen_HTML_Core from "../Halogen.HTML.Core/index.js";
import * as Halogen_HTML_Elements from "../Halogen.HTML.Elements/index.js";
import * as Halogen_HTML_Properties from "../Halogen.HTML.Properties/index.js";
import * as Hydrogen_UI_Core from "../Hydrogen.UI.Core/index.js";
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var show1 = /* #__PURE__ */ Data_Show.show(Data_Show.showInt);
var map1 = /* #__PURE__ */ Data_Functor.map(Data_Maybe.functorMaybe);
var append1 = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var bind = /* #__PURE__ */ Control_Bind.bind(Control_Bind.bindArray);
var maximum = /* #__PURE__ */ Data_Foldable.maximum(Data_Ord.ordNumber)(Data_Foldable.foldableArray);
var minimum = /* #__PURE__ */ Data_Foldable.minimum(Data_Ord.ordNumber)(Data_Foldable.foldableArray);
var div1 = /* #__PURE__ */ Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt);
var sum = /* #__PURE__ */ Data_Foldable.sum(Data_Foldable.foldableArray)(Data_Semiring.semiringNumber);

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                 // curve types
// ═══════════════════════════════════════════════════════════════════════════════
// | Line interpolation type
var Linear = /* #__PURE__ */ (function () {
    function Linear() {

    };
    Linear.value = new Linear();
    return Linear;
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                 // curve types
// ═══════════════════════════════════════════════════════════════════════════════
// | Line interpolation type
var Bezier = /* #__PURE__ */ (function () {
    function Bezier() {

    };
    Bezier.value = new Bezier();
    return Bezier;
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                 // curve types
// ═══════════════════════════════════════════════════════════════════════════════
// | Line interpolation type
var Step = /* #__PURE__ */ (function () {
    function Step() {

    };
    Step.value = new Step();
    return Step;
})();

// | Show/hide tooltips
var showTooltip = function (v) {
    return function (props) {
        return {
            series: props.series,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showGrid: props.showGrid,
            showLegend: props.showLegend,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            padding: props.padding,
            className: props.className,
            showTooltip: v
        };
    };
};

// | Show/hide legend
var showLegend = function (v) {
    return function (props) {
        return {
            series: props.series,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            padding: props.padding,
            className: props.className,
            showLegend: v
        };
    };
};

// | Show/hide grid lines
var showGrid = function (v) {
    return function (props) {
        return {
            series: props.series,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            padding: props.padding,
            className: props.className,
            showGrid: v
        };
    };
};

// | Show/hide axis labels
var showAxisLabels = function (v) {
    return function (props) {
        return {
            series: props.series,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            animated: props.animated,
            padding: props.padding,
            className: props.className,
            showAxisLabels: v
        };
    };
};

// | Minimum of two integers
var min = function (a) {
    return function (b) {
        var $58 = a < b;
        if ($58) {
            return a;
        };
        return b;
    };
};

// | Step path starting with M
var generateStepPath = function (points) {
    var v = Data_Array.uncons(points);
    if (v instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v instanceof Data_Maybe.Just) {
        return "M " + (show(v.value0.head.x) + (" " + (show(v.value0.head.y) + foldl(function (acc) {
            return function (p) {
                return acc + (" H " + (show(p.x) + (" V " + show(p.y))));
            };
        })("")(v.value0.tail))));
    };
    throw new Error("Failed pattern match at Hydrogen.Chart.AreaChart (line 672, column 3 - line 676, column 78): " + [ v.constructor.name ]);
};

// | Step path continuing (no M)
var generateStepContinuePath = function (points) {
    return foldl(function (acc) {
        return function (p) {
            return acc + (" H " + (show(p.x) + (" V " + show(p.y))));
        };
    })("")(points);
};

// | Linear path starting with M
var generateLinearPath = function (points) {
    var v = Data_Array.uncons(points);
    if (v instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v instanceof Data_Maybe.Just) {
        return "M " + (show(v.value0.head.x) + (" " + (show(v.value0.head.y) + foldl(function (acc) {
            return function (p) {
                return acc + (" L " + (show(p.x) + (" " + show(p.y))));
            };
        })("")(v.value0.tail))));
    };
    throw new Error("Failed pattern match at Hydrogen.Chart.AreaChart (line 591, column 3 - line 595, column 76): " + [ v.constructor.name ]);
};

// | Linear path continuing (no M, starts with L)
var generateLinearContinuePath = function (points) {
    return foldl(function (acc) {
        return function (p) {
            return acc + (" L " + (show(p.x) + (" " + show(p.y))));
        };
    })("")(points);
};

// | Bezier path starting with M
var generateBezierPath = function (points) {
    var v = Data_Array.uncons(points);
    if (v instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v instanceof Data_Maybe.Just) {
        var buildCurve = function (acc) {
            return function (curr) {
                var cp2y = curr.y - (curr.y - acc.prev.y) * 0.3;
                var cp2x = curr.x - (curr.x - acc.prev.x) * 0.3;
                var cp1y = acc.prev.y + (curr.y - acc.prevPrev.y) * 0.3;
                var cp1x = acc.prev.x + (curr.x - acc.prevPrev.x) * 0.3;
                return {
                    path: acc.path + (" C " + (show(cp1x) + (" " + (show(cp1y) + (", " + (show(cp2x) + (" " + (show(cp2y) + (", " + (show(curr.x) + (" " + show(curr.y)))))))))))),
                    prev: curr,
                    prevPrev: acc.prev
                };
            };
        };
        var v1 = Data_Array.uncons(v.value0.tail);
        if (v1 instanceof Data_Maybe.Nothing) {
            return "M " + (show(v.value0.head.x) + (" " + show(v.value0.head.y)));
        };
        if (v1 instanceof Data_Maybe.Just) {
            var initial = {
                path: "M " + (show(v.value0.head.x) + (" " + (show(v.value0.head.y) + (" L " + (show(v1.value0.head.x) + (" " + show(v1.value0.head.y))))))),
                prev: v1.value0.head,
                prevPrev: v.value0.head
            };
            var result = foldl(buildCurve)(initial)(v1.value0.tail);
            return result.path;
        };
        throw new Error("Failed pattern match at Hydrogen.Chart.AreaChart (line 626, column 9 - line 638, column 26): " + [ v1.constructor.name ]);
    };
    throw new Error("Failed pattern match at Hydrogen.Chart.AreaChart (line 605, column 3 - line 638, column 26): " + [ v.constructor.name ]);
};

// | Bezier path continuing (no M)
var generateBezierContinuePath = function (points) {
    var v = Data_Array.uncons(points);
    if (v instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v instanceof Data_Maybe.Just) {
        var initial = {
            path: " L " + (show(v.value0.head.x) + (" " + show(v.value0.head.y))),
            prev: v.value0.head,
            prevPrev: v.value0.head
        };
        var buildCurve = function (acc) {
            return function (curr) {
                var cp2y = curr.y - (curr.y - acc.prev.y) * 0.3;
                var cp2x = curr.x - (curr.x - acc.prev.x) * 0.3;
                var cp1y = acc.prev.y + (curr.y - acc.prevPrev.y) * 0.3;
                var cp1x = acc.prev.x + (curr.x - acc.prevPrev.x) * 0.3;
                return {
                    path: acc.path + (" C " + (show(cp1x) + (" " + (show(cp1y) + (", " + (show(cp2x) + (" " + (show(cp2y) + (", " + (show(curr.x) + (" " + show(curr.y)))))))))))),
                    prev: curr,
                    prevPrev: acc.prev
                };
            };
        };
        var result = foldl(buildCurve)(initial)(v.value0.tail);
        return result.path;
    };
    throw new Error("Failed pattern match at Hydrogen.Chart.AreaChart (line 643, column 3 - line 667, column 20): " + [ v.constructor.name ]);
};

// | Generate area path from top and bottom point arrays
var generateAreaPath = function (cType) {
    return function (topPoints) {
        return function (bottomPoints) {
            var topPath = (function () {
                if (cType instanceof Linear) {
                    return generateLinearPath(topPoints);
                };
                if (cType instanceof Bezier) {
                    return generateBezierPath(topPoints);
                };
                if (cType instanceof Step) {
                    return generateStepPath(topPoints);
                };
                throw new Error("Failed pattern match at Hydrogen.Chart.AreaChart (line 576, column 15 - line 579, column 41): " + [ cType.constructor.name ]);
            })();
            var bottomPath = (function () {
                if (cType instanceof Linear) {
                    return generateLinearContinuePath(bottomPoints);
                };
                if (cType instanceof Bezier) {
                    return generateBezierContinuePath(bottomPoints);
                };
                if (cType instanceof Step) {
                    return generateStepContinuePath(bottomPoints);
                };
                throw new Error("Failed pattern match at Hydrogen.Chart.AreaChart (line 581, column 18 - line 584, column 52): " + [ cType.constructor.name ]);
            })();
            return topPath + (bottomPath + " Z");
        };
    };
};

// ═══════════════════════════════════════════════════════════════════════════════
//                                                                     // helpers
// ═══════════════════════════════════════════════════════════════════════════════
// | Format number for display
var formatNumber = function (n) {
    var absN = Data_Number.abs(n);
    var $81 = absN >= 1000000.0;
    if ($81) {
        return show(n / 1000000.0) + "M";
    };
    var $82 = absN >= 1000.0;
    if ($82) {
        return show(n / 1000.0) + "K";
    };
    return show(n);
};

// | Stacked area chart with full props
var stackedAreaChartWithProps = function (props) {
    
    // Legend
var legend = (function () {
        if (props.showLegend) {
            return map(function (s) {
                return Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "flex items-center gap-2" ]) ])([ Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "w-4 h-3 rounded-sm" ]), Halogen_HTML_Properties.style("background-color: " + s.color) ])([  ]), Halogen_HTML_Elements.span([ Hydrogen_UI_Core.cls([ "text-xs text-muted-foreground" ]) ])([ Halogen_HTML_Core.text(s.label) ]) ]);
            })(props.series);
        };
        return [  ];
    })();
    
    // Generate gradient definitions
var gradientDefs = Data_Array.mapWithIndex(function (idx) {
        return function (s) {
            return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("linearGradient")([ Halogen_HTML_Properties.attr("id")("areaGradient" + show1(idx)), Halogen_HTML_Properties.attr("x1")("0%"), Halogen_HTML_Properties.attr("y1")("0%"), Halogen_HTML_Properties.attr("x2")("0%"), Halogen_HTML_Properties.attr("y2")("100%") ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("stop")([ Halogen_HTML_Properties.attr("offset")("0%"), Halogen_HTML_Properties.attr("stop-color")(s.color), Halogen_HTML_Properties.attr("stop-opacity")("0.8") ])([  ]), Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("stop")([ Halogen_HTML_Properties.attr("offset")("100%"), Halogen_HTML_Properties.attr("stop-color")(s.color), Halogen_HTML_Properties.attr("stop-opacity")("0.3") ])([  ]) ]);
        };
    })(props.series);
    var chartWidth = Data_Int.toNumber(props.width) - props.padding.left - props.padding.right;
    var chartHeight = Data_Int.toNumber(props.height) - props.padding.top - props.padding.bottom;
    
    // Grid lines
var gridLines = (function () {
        if (props.showGrid) {
            var lineSpacing = chartHeight / Data_Int.toNumber(5);
            return Data_Array.mapWithIndex(function (idx) {
                return function (v) {
                    var y = props.padding.top + Data_Int.toNumber(idx) * lineSpacing;
                    return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("line")([ Halogen_HTML_Properties.attr("x1")(show(props.padding.left)), Halogen_HTML_Properties.attr("y1")(show(y)), Halogen_HTML_Properties.attr("x2")(show(props.padding.left + chartWidth)), Halogen_HTML_Properties.attr("y2")(show(y)), Hydrogen_UI_Core.svgCls([ "stroke-muted-foreground/20" ]), Halogen_HTML_Properties.attr("stroke-dasharray")("4,4") ])([  ]);
                };
            })(Data_Array.replicate(5 + 1 | 0)(Data_Unit.unit));
        };
        return [  ];
    })();
    
    // Get all x values (assuming all series share x values)
var allXValues = (function () {
        var v = Data_Array.head(props.series);
        if (v instanceof Data_Maybe.Just) {
            return map(function (v1) {
                return v1.x;
            })(v.value0.data);
        };
        if (v instanceof Data_Maybe.Nothing) {
            return [  ];
        };
        throw new Error("Failed pattern match at Hydrogen.Chart.AreaChart (line 202, column 18 - line 204, column 20): " + [ v.constructor.name ]);
    })();
    var numPoints = Data_Array.length(allXValues);
    
    // Calculate stacked y values
    // For each x index, compute cumulative y values for stacking
var stackedValues = (function () {
        var initialTops = Data_Array.replicate(numPoints)(0.0);
        
        // Get y values at each x index for each series
var getYAtIndex = function (idx) {
            return function (s) {
                return Data_Maybe.fromMaybe(0.0)(map1(function (v) {
                    return v.y;
                })(Data_Array.index(s.data)(idx)));
            };
        };
        
        // Build stacked values series by series
var buildStacks = function (acc) {
            return function (series) {
                var stackPoints = Data_Array.mapWithIndex(function (idx) {
                    return function (x) {
                        var y = getYAtIndex(idx)(series);
                        var prevTop = Data_Maybe.fromMaybe(0.0)(Data_Array.index(acc.prevTops)(idx));
                        return {
                            x: x,
                            y0: prevTop,
                            y1: prevTop + y
                        };
                    };
                })(allXValues);
                var newTops = map(function (v) {
                    return v.y1;
                })(stackPoints);
                return {
                    stacks: append1(acc.stacks)([ stackPoints ]),
                    prevTops: newTops
                };
            };
        };
        var result = foldl(buildStacks)({
            stacks: [  ],
            prevTops: initialTops
        })(props.series);
        return result.stacks;
    })();
    
    // Calculate y range
var allY1Values = bind(stackedValues)(map(function (v) {
        return v.y1;
    }));
    var yMax = Data_Maybe.fromMaybe(1.0)(maximum(allY1Values));
    var scaleY = function (y) {
        return props.padding.top + (1.0 - y / yMax) * chartHeight;
    };
    
    // Y-axis labels
var yAxisLabels = (function () {
        if (props.showAxisLabels) {
            var valueSpacing = yMax / Data_Int.toNumber(5);
            var labelSpacing = chartHeight / Data_Int.toNumber(5);
            return Data_Array.mapWithIndex(function (idx) {
                return function (v) {
                    var y = props.padding.top + Data_Int.toNumber(5 - idx | 0) * labelSpacing;
                    var val = Data_Int.toNumber(idx) * valueSpacing;
                    return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("text")([ Halogen_HTML_Properties.attr("x")(show(props.padding.left - 8.0)), Halogen_HTML_Properties.attr("y")(show(y + 4.0)), Halogen_HTML_Properties.attr("text-anchor")("end"), Hydrogen_UI_Core.svgCls([ "fill-muted-foreground text-xs" ]) ])([ Halogen_HTML_Core.text(formatNumber(val)) ]);
                };
            })(Data_Array.replicate(5 + 1 | 0)(Data_Unit.unit));
        };
        return [  ];
    })();
    var xMax = Data_Maybe.fromMaybe(1.0)(maximum(allXValues));
    
    // Calculate x range
var xMin = Data_Maybe.fromMaybe(0.0)(minimum(allXValues));
    var xRange = (function () {
        var $88 = xMax === xMin;
        if ($88) {
            return 1.0;
        };
        return xMax - xMin;
    })();
    
    // Scale point to chart coordinates
var scaleX = function (x) {
        return props.padding.left + ((x - xMin) / xRange) * chartWidth;
    };
    
    // Generate area paths (in reverse order so first series is on top)
var areaPaths = Data_Array.mapWithIndex(function (idx) {
        return function (stackData) {
            
            // Build path: top line forward, then bottom line backward
var topPoints = map(function (p) {
                return {
                    x: scaleX(p.x),
                    y: scaleY(p.y1)
                };
            })(stackData);
            var series = Data_Maybe.fromMaybe({
                label: "",
                data: [  ],
                color: "#3b82f6"
            })(Data_Array.index(props.series)(idx));
            var bottomPoints = Data_Array.reverse(map(function (p) {
                return {
                    x: scaleX(p.x),
                    y: scaleY(p.y0)
                };
            })(stackData));
            var pathData = generateAreaPath(props.curveType)(topPoints)(bottomPoints);
            return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("path")([ Halogen_HTML_Properties.attr("d")(pathData), Halogen_HTML_Properties.attr("fill")("url(#areaGradient" + (show1(idx) + ")")), Halogen_HTML_Properties.attr("stroke")(series.color), Halogen_HTML_Properties.attr("stroke-width")("1"), Hydrogen_UI_Core.svgCls([ "hover:opacity-80 transition-opacity" ]) ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("title")([  ])([ Halogen_HTML_Core.text(series.label) ]) ]);
        };
    })(stackedValues);
    
    // X-axis labels
var xAxisLabels = (function () {
        if (props.showAxisLabels) {
            var numLabels = min(6)(numPoints);
            var labelIndices = (function () {
                var $90 = numPoints <= numLabels;
                if ($90) {
                    return Data_Array.range(0)(numPoints - 1 | 0);
                };
                return Data_Array.mapWithIndex(function (i) {
                    return function (v) {
                        return div1(i * (numPoints - 1 | 0) | 0)(numLabels - 1 | 0);
                    };
                })(Data_Array.replicate(numLabels)(Data_Unit.unit));
            })();
            return map(function (idx) {
                var xVal = Data_Maybe.fromMaybe(0.0)(Data_Array.index(allXValues)(idx));
                var x = scaleX(xVal);
                return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("text")([ Halogen_HTML_Properties.attr("x")(show(x)), Halogen_HTML_Properties.attr("y")(show(props.padding.top + chartHeight + 20.0)), Halogen_HTML_Properties.attr("text-anchor")("middle"), Hydrogen_UI_Core.svgCls([ "fill-muted-foreground text-xs" ]) ])([ Halogen_HTML_Core.text(formatNumber(xVal)) ]);
            })(labelIndices);
        };
        return [  ];
    })();
    return Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "relative", props.className ]) ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("svg")([ Hydrogen_UI_Core.svgCls([ "w-full h-auto" ]), Halogen_HTML_Properties.attr("viewBox")("0 0 " + (show1(props.width) + (" " + show1(props.height)))), Halogen_HTML_Properties.attr("preserveAspectRatio")("xMidYMid meet") ])(append1([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("defs")([  ])(gradientDefs) ])(append1(gridLines)(append1(yAxisLabels)(append1(xAxisLabels)(Data_Array.reverse(areaPaths)))))), (function () {
        if (props.showLegend) {
            return Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "flex flex-wrap gap-4 justify-center mt-4" ]) ])(legend);
        };
        return Halogen_HTML_Core.text("");
    })() ]);
};
var eqCurveType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Linear && y instanceof Linear) {
                return true;
            };
            if (x instanceof Bezier && y instanceof Bezier) {
                return true;
            };
            if (x instanceof Step && y instanceof Step) {
                return true;
            };
            return false;
        };
    }
};

// | Default stacked area chart properties
var defaultProps = /* #__PURE__ */ (function () {
    return {
        series: [  ],
        width: 400,
        height: 300,
        curveType: Bezier.value,
        showGrid: true,
        showTooltip: true,
        showLegend: true,
        showAxisLabels: true,
        animated: true,
        padding: {
            top: 20.0,
            right: 20.0,
            bottom: 40.0,
            left: 50.0
        },
        className: ""
    };
})();

// ═══════════════════════════════════════════════════════════════════════════════
//                                                          // stacked area chart
// ═══════════════════════════════════════════════════════════════════════════════
// | Simple stacked area chart
var stackedAreaChart = function (config) {
    return stackedAreaChartWithProps({
        curveType: defaultProps.curveType,
        showGrid: defaultProps.showGrid,
        showTooltip: defaultProps.showTooltip,
        showLegend: defaultProps.showLegend,
        showAxisLabels: defaultProps.showAxisLabels,
        animated: defaultProps.animated,
        padding: defaultProps.padding,
        className: defaultProps.className,
        series: config.series,
        width: config.width,
        height: config.height
    });
};

// | Stream graph (centered stacked area)
var streamGraph = function (config) {
    var props = {
        animated: defaultProps.animated,
        className: defaultProps.className,
        curveType: defaultProps.curveType,
        padding: defaultProps.padding,
        showAxisLabels: defaultProps.showAxisLabels,
        showGrid: defaultProps.showGrid,
        showLegend: defaultProps.showLegend,
        showTooltip: defaultProps.showTooltip,
        series: config.series,
        width: config.width,
        height: config.height
    };
    
    // Legend
var legend = map(function (s) {
        return Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "flex items-center gap-2" ]) ])([ Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "w-4 h-3 rounded-sm" ]), Halogen_HTML_Properties.style("background-color: " + s.color) ])([  ]), Halogen_HTML_Elements.span([ Hydrogen_UI_Core.cls([ "text-xs text-muted-foreground" ]) ])([ Halogen_HTML_Core.text(s.label) ]) ]);
    })(config.series);
    
    // Generate gradient definitions
var gradientDefs = Data_Array.mapWithIndex(function (idx) {
        return function (s) {
            return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("linearGradient")([ Halogen_HTML_Properties.attr("id")("streamGradient" + show1(idx)), Halogen_HTML_Properties.attr("x1")("0%"), Halogen_HTML_Properties.attr("y1")("0%"), Halogen_HTML_Properties.attr("x2")("0%"), Halogen_HTML_Properties.attr("y2")("100%") ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("stop")([ Halogen_HTML_Properties.attr("offset")("0%"), Halogen_HTML_Properties.attr("stop-color")(s.color), Halogen_HTML_Properties.attr("stop-opacity")("0.9") ])([  ]), Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("stop")([ Halogen_HTML_Properties.attr("offset")("100%"), Halogen_HTML_Properties.attr("stop-color")(s.color), Halogen_HTML_Properties.attr("stop-opacity")("0.6") ])([  ]) ]);
        };
    })(config.series);
    
    // Calculate total at each x index
var getTotalAtIndex = function (idx) {
        return sum(map(function (s) {
            return Data_Maybe.fromMaybe(0.0)(map1(function (v) {
                return v.y;
            })(Data_Array.index(s.data)(idx)));
        })(config.series));
    };
    var chartWidth = Data_Int.toNumber(config.width) - props.padding.left - props.padding.right;
    var chartHeight = Data_Int.toNumber(config.height) - props.padding.top - props.padding.bottom;
    
    // Get all x values
var allXValues = (function () {
        var v = Data_Array.head(config.series);
        if (v instanceof Data_Maybe.Just) {
            return map(function (v1) {
                return v1.x;
            })(v.value0.data);
        };
        if (v instanceof Data_Maybe.Nothing) {
            return [  ];
        };
        throw new Error("Failed pattern match at Hydrogen.Chart.AreaChart (line 432, column 18 - line 434, column 20): " + [ v.constructor.name ]);
    })();
    
    // Get max total for scaling
var maxTotal = Data_Maybe.fromMaybe(1.0)(maximum(Data_Array.mapWithIndex(function (i) {
        return function (v) {
            return getTotalAtIndex(i);
        };
    })(allXValues)));
    var scaleY = function (y) {
        return (props.padding.top + chartHeight / 2.0) - (y / maxTotal) * chartHeight;
    };
    var numPoints = Data_Array.length(allXValues);
    
    // Build stream centered stacks
var streamStacks = (function () {
        var initialTops = Data_Array.mapWithIndex(function (i) {
            return function (v) {
                return -getTotalAtIndex(i) / 2.0;
            };
        })(allXValues);
        var getYAtIndex = function (idx) {
            return function (s) {
                return Data_Maybe.fromMaybe(0.0)(map1(function (v) {
                    return v.y;
                })(Data_Array.index(s.data)(idx)));
            };
        };
        
        // For each x, center the stack around y=0
var buildStream = function (acc) {
            return function (series) {
                var stackPoints = Data_Array.mapWithIndex(function (idx) {
                    return function (x) {
                        var y = getYAtIndex(idx)(series);
                        var total = getTotalAtIndex(idx);
                        var offset = -total / 2.0;
                        var prevTop = Data_Maybe.fromMaybe(offset)(Data_Array.index(acc.prevTops)(idx));
                        return {
                            x: x,
                            y0: prevTop,
                            y1: prevTop + y
                        };
                    };
                })(allXValues);
                var newTops = map(function (v) {
                    return v.y1;
                })(stackPoints);
                return {
                    stacks: append1(acc.stacks)([ stackPoints ]),
                    prevTops: newTops
                };
            };
        };
        var result = foldl(buildStream)({
            stacks: [  ],
            prevTops: initialTops
        })(config.series);
        return result.stacks;
    })();
    var xMax = Data_Maybe.fromMaybe(1.0)(maximum(allXValues));
    
    // Calculate x range
var xMin = Data_Maybe.fromMaybe(0.0)(minimum(allXValues));
    var xRange = (function () {
        var $96 = xMax === xMin;
        if ($96) {
            return 1.0;
        };
        return xMax - xMin;
    })();
    
    // Scale functions
var scaleX = function (x) {
        return props.padding.left + ((x - xMin) / xRange) * chartWidth;
    };
    
    // Generate stream paths
var streamPaths = Data_Array.mapWithIndex(function (idx) {
        return function (stackData) {
            var topPoints = map(function (p) {
                return {
                    x: scaleX(p.x),
                    y: scaleY(p.y1)
                };
            })(stackData);
            var series = Data_Maybe.fromMaybe({
                label: "",
                data: [  ],
                color: "#3b82f6"
            })(Data_Array.index(config.series)(idx));
            var bottomPoints = Data_Array.reverse(map(function (p) {
                return {
                    x: scaleX(p.x),
                    y: scaleY(p.y0)
                };
            })(stackData));
            var pathData = generateAreaPath(Bezier.value)(topPoints)(bottomPoints);
            return Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("path")([ Halogen_HTML_Properties.attr("d")(pathData), Halogen_HTML_Properties.attr("fill")("url(#streamGradient" + (show1(idx) + ")")), Halogen_HTML_Properties.attr("stroke")(series.color), Halogen_HTML_Properties.attr("stroke-width")("0.5"), Hydrogen_UI_Core.svgCls([ "hover:opacity-80 transition-opacity" ]) ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("title")([  ])([ Halogen_HTML_Core.text(series.label) ]) ]);
        };
    })(streamStacks);
    return Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "relative" ]) ])([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("svg")([ Hydrogen_UI_Core.svgCls([ "w-full h-auto" ]), Halogen_HTML_Properties.attr("viewBox")("0 0 " + (show1(config.width) + (" " + show1(config.height)))), Halogen_HTML_Properties.attr("preserveAspectRatio")("xMidYMid meet") ])(append1([ Halogen_HTML_Elements.elementNS(Hydrogen_UI_Core.svgNS)("defs")([  ])(gradientDefs) ])(Data_Array.reverse(streamPaths))), Halogen_HTML_Elements.div([ Hydrogen_UI_Core.cls([ "flex flex-wrap gap-4 justify-center mt-4" ]) ])(legend) ]);
};

// | Set curve interpolation type
var curveType = function (c) {
    return function (props) {
        return {
            series: props.series,
            width: props.width,
            height: props.height,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            padding: props.padding,
            className: props.className,
            curveType: c
        };
    };
};

// | Add custom class
var className = function (c) {
    return function (props) {
        return {
            series: props.series,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showAxisLabels: props.showAxisLabels,
            animated: props.animated,
            padding: props.padding,
            className: props.className + (" " + c)
        };
    };
};

// | Enable/disable animation
var animated = function (v) {
    return function (props) {
        return {
            series: props.series,
            width: props.width,
            height: props.height,
            curveType: props.curveType,
            showGrid: props.showGrid,
            showTooltip: props.showTooltip,
            showLegend: props.showLegend,
            showAxisLabels: props.showAxisLabels,
            padding: props.padding,
            className: props.className,
            animated: v
        };
    };
};
export {
    stackedAreaChart,
    stackedAreaChartWithProps,
    defaultProps,
    streamGraph,
    Linear,
    Bezier,
    Step,
    curveType,
    showGrid,
    showTooltip,
    showLegend,
    showAxisLabels,
    animated,
    className,
    eqCurveType
};
