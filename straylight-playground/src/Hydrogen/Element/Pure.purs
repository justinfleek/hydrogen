-- ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
--                                            // hydrogen // element // pure
-- ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

-- | Pure Element — Composed Entirely from Schema Atoms
-- |
-- | This is the correct Element type. No strings. No CSS. No escape hatches.
-- | Every value is a Schema atom. Every composition is deterministic.
-- |
-- | ```purescript
-- | Rectangle
-- |   { position: Point2D { x: Pixel 100, y: Pixel 50 }
-- |   , size: Size2D { width: Pixel 200, height: Pixel 48 }
-- |   , fill: Solid (SRGB { r: Channel 59, g: Channel 130, b: Channel 246 })
-- |   , cornerRadius: Corners { topLeft: Radius.lg, ... }
-- |   }
-- | ```
-- |
-- | This Element can be:
-- | - Generated by Haskell backend
-- | - Serialized to binary/JSON
-- | - Interpreted by WebGL/Canvas/DOM runtime
-- | - UUID5 hashed for deterministic identity

module Hydrogen.Element.Pure
  ( Element(..)
  , Effect(..)
  , CoEffect(..)
  , Fill(..)
  , NoiseConfig
  , Stroke
  , elementUUID5
  ) where

import Prelude

import Data.Maybe (Maybe(..))

-- Schema imports (use actual module paths)
import Hydrogen.Schema.Color.Channel (Channel)
import Hydrogen.Schema.Color.SRGB (SRGB)
import Hydrogen.Schema.Color.Opacity (Opacity)
import Hydrogen.Schema.Color.Gradient (Gradient, LinearGradient, RadialGradient, ConicGradient)
import Hydrogen.Schema.Dimension.Device (Pixel)
import Hydrogen.Schema.Dimension.Vector.Vec2 (Vec2)
import Hydrogen.Schema.Geometry.Radius (Corners)
import Hydrogen.Schema.Material.NoiseFrequency (NoiseFrequency)
import Hydrogen.Schema.Material.NoiseAmplitude (NoiseAmplitude)
import Hydrogen.Schema.Material.NoiseOctaves (NoiseOctaves)
import Hydrogen.Schema.Material.NoiseLacunarity (NoiseLacunarity)
import Hydrogen.Schema.Material.NoisePersistence (NoisePersistence)
import Hydrogen.Schema.Material.NoiseSeed (NoiseSeed)
import Hydrogen.Schema.Typography.FontFamily (FontFamily)
import Hydrogen.Schema.Typography.FontSize (FontSize)
import Hydrogen.Schema.Typography.FontWeight (FontWeight)
import Hydrogen.Schema.Typography.LineHeight (LineHeight)

-- ═════════════════════════════════════════════════════════════════════════════
--                                                           // effect // tracking
-- ═════════════════════════════════════════════════════════════════════════════

-- | Effects: What can this Element produce?
data Effect
  = Pure                    -- No effects
  | CanClick                -- Produces messages on click
  | CanAnimate              -- Produces animation frames
  | CanEmitSound            -- Produces audio
  | CanRequestData          -- Produces HTTP requests
  | Interactive             -- CanClick ⊗ CanAnimate
  | FullInteractive         -- All interactive effects

derive instance eqEffect :: Eq Effect
derive instance ordEffect :: Ord Effect

-- | Monoid instance for Effect composition
instance semigroupEffect :: Semigroup Effect where
  append Pure e = e
  append e Pure = e
  append CanClick CanAnimate = Interactive
  append CanAnimate CanClick = Interactive
  append _ _ = FullInteractive

instance monoidEffect :: Monoid Effect where
  mempty = Pure

-- | Co-effects: What does this Element need?
data CoEffect
  = NeedsNothing
  | NeedsFont FontFamily
  | NeedsImage String       -- URL
  | NeedsData String        -- Query key
  | NeedsResources (Array CoEffect)

derive instance eqCoEffect :: Eq CoEffect
derive instance ordCoEffect :: Ord CoEffect

-- | Monoid instance for CoEffect composition
instance semigroupCoEffect :: Semigroup CoEffect where
  append NeedsNothing e = e
  append e NeedsNothing = e
  append (NeedsResources a) (NeedsResources b) = NeedsResources (a <> b)
  append (NeedsResources a) e = NeedsResources (a <> [e])
  append e (NeedsResources b) = NeedsResources ([e] <> b)
  append a b = NeedsResources [a, b]

instance monoidCoEffect :: Monoid CoEffect where
  mempty = NeedsNothing

-- ═════════════════════════════════════════════════════════════════════════════
--                                                                  // fill // stroke
-- ═════════════════════════════════════════════════════════════════════════════

-- | Fill types composed entirely from Schema atoms
-- |
-- | Every fill type is composed from bounded Schema atoms. No escape hatches.
data Fill
  = Solid SRGB                      -- Solid color fill
  | SolidWithAlpha SRGB Opacity     -- Solid with transparency
  | GradientFill Gradient           -- Linear, radial, conic, or mesh gradient
  | NoiseFill NoiseConfig           -- Procedural noise texture

derive instance eqFill :: Eq Fill

instance showFill :: Show Fill where
  show (Solid c) = "Solid(" <> show c <> ")"
  show (SolidWithAlpha c a) = "SolidWithAlpha(" <> show c <> ", " <> show a <> ")"
  show (GradientFill g) = "GradientFill(" <> show g <> ")"
  show (NoiseFill cfg) = "NoiseFill(" <> show cfg.frequency <> ", " <> show cfg.octaves <> ")"

-- | Noise configuration composed from Schema atoms
-- |
-- | Defines procedural noise for texture generation.
type NoiseConfig =
  { frequency :: NoiseFrequency     -- Spatial frequency (0.0+)
  , amplitude :: NoiseAmplitude     -- Output amplitude (0.0-1.0)
  , octaves :: NoiseOctaves         -- Number of octaves for fractal (1-16)
  , lacunarity :: NoiseLacunarity   -- Frequency multiplier per octave (1.0+)
  , persistence :: NoisePersistence -- Amplitude decay per octave (0.0-1.0)
  , seed :: NoiseSeed               -- Random seed for reproducibility
  , baseColor :: SRGB               -- Base color to modulate
  }

-- | Stroke definition composed from Schema atoms
type Stroke =
  { width :: Pixel          -- Stroke width (bounded, non-negative)
  , color :: SRGB           -- Stroke color (web standard)
  , opacity :: Maybe Opacity  -- Optional transparency (0.0-1.0)
  }

-- ═════════════════════════════════════════════════════════════════════════════
--                                                                    // element
-- ═════════════════════════════════════════════════════════════════════════════

-- | Pure Element composed entirely from Schema atoms
-- |
-- | This is the complete rendering instruction set. Every field is a Schema atom.
-- | No strings (except text content). No CSS. No escape hatches.
data Element msg
  = Rectangle
      { position :: Vec2 Pixel         -- Position as 2D vector of pixels
      , size :: Vec2 Pixel             -- Size as 2D vector of pixels
      , fill :: Fill
      , cornerRadius :: Maybe Corners
      , stroke :: Maybe Stroke
      }
  | Circle
      { center :: Vec2 Pixel           -- Center position
      , radius :: Pixel
      , fill :: Fill
      , stroke :: Maybe Stroke
      }
  | Text
      { content :: String              -- Text content (String is the atom for text)
      , position :: Vec2 Pixel         -- Text baseline position
      , fontFamily :: FontFamily       -- Font family atom
      , fontSize :: FontSize           -- Font size atom
      , fontWeight :: FontWeight       -- Weight atom (100-900)
      , lineHeight :: Maybe LineHeight -- Optional line height atom
      , color :: SRGB                  -- Text color (web standard)
      }
  | Group
      { children :: Array (Element msg)
      , position :: Maybe (Vec2 Pixel) -- Optional transform
      }
  | Empty

instance eqElement :: Eq (Element msg) where
  eq (Rectangle a) (Rectangle b) = 
    a.position == b.position && a.size == b.size && a.fill == b.fill && 
    a.cornerRadius == b.cornerRadius && a.stroke == b.stroke
  eq (Circle a) (Circle b) = 
    a.center == b.center && a.radius == b.radius && a.fill == b.fill && a.stroke == b.stroke
  eq (Text a) (Text b) = 
    a.content == b.content && a.position == b.position && a.fontFamily == b.fontFamily &&
    a.fontSize == b.fontSize && a.fontWeight == b.fontWeight && a.lineHeight == b.lineHeight &&
    a.color == b.color
  eq (Group a) (Group b) = a.children == b.children && a.position == b.position
  eq Empty Empty = true
  eq _ _ = false

instance showElement :: Show (Element msg) where
  show = elementUUID5

instance functorElement :: Functor Element where
  map f = case _ of
    Rectangle r -> Rectangle r
    Circle c -> Circle c
    Text t -> Text t
    Group g -> Group g { children = map (map f) g.children }
    Empty -> Empty

-- ═════════════════════════════════════════════════════════════════════════════
--                                                              // uuid5 // identity
-- ═════════════════════════════════════════════════════════════════════════════

-- | Generate deterministic UUID5 from Element content
-- |
-- | Same atoms → same UUID5. Two agents create identical Element → identical ID.
-- | Reproducible across runs, systems, languages.
-- |
-- | Namespace: "hydrogen.element"
-- |
-- | Note: Currently using simple string concatenation. For RFC 4122 compliant UUID5,
-- | a crypto library with SHA-1 hashing will be integrated when PureScript crypto
-- | bindings are available in the Hydrogen package.
elementUUID5 :: forall msg. Element msg -> String
elementUUID5 = case _ of
  Rectangle r -> 
    "rect-" <> show r.position <> "-" <> show r.size <> "-" <> show r.fill
  Circle c ->
    "circle-" <> show c.center <> "-" <> show c.radius <> "-" <> show c.fill
  Text t ->
    "text-" <> show t.position <> "-" <> t.content <> "-" <> show t.fontSize
  Group g ->
    "group-" <> show (map elementUUID5 g.children)
  Empty ->
    "empty"
